<!-- performance  -->
<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Dark Page</title>

<script src="https://cdn.jsdelivr.net/npm/appwrite@18.2.0"></script>

<style>
/* Reset e base */
body, html {
  margin: 0;
  padding: 0;
  font-family: Arial, sans-serif;
  background: #000;
  color: #fff;
}

main { 
padding: 70px 16px 90px; text-align: center; }

section { display: none; }           /* todas escondidas */

section.active { display: block; }   /* vis√≠vel */

a {
  flex-direction: column;
}

/* Estilos gerais para Header e Footer */
header, footer {
  position: fixed;
  left: 0;
  right: 0;
  display: flex;
  align-items: center;
  justify-content: space-between;
  background: #000;
  padding: 0 16px;
  color: #fff;
  user-select: none;
  z-index: 1000;
}

  /* ===============  */
 /*      Header      */
/* ===============  */
header {
  top: 0;
  height: 56px;
  border-bottom: 1px solid #222; 
  font-weight: 600;
}

.logo-area {
  color: #fff;  
  border-radius: 15%;
  display: flex;
  align-items: center;
  gap: 10px;
  cursor: pointer;
}

.logo-area img {
  background: #fff; 
  color: #000;  
  border-radius: 15%;
  width: 30px;
  height: 30px;
  border-radius: 4px;
}

.icon {
  width: 24px; 
  height: 24px;
}

.icons-right {
	display: flex;
	align-items: center;
	gap: 20px;
	color: #6d28d9;
	text-decoration: none;
	cursor: pointer;
}

.icons-right a {
  color: #6d28d9;
  text-decoration: none;
  margin-left: 20px;
  display: flex;
  align-items: center;
  transition: color 0.3s ease;
  cursor: pointer;
}

.icons-right svg, header svg {
  width: 24px;
  height: 24px;
  fill: currentColor;
}
  /* ===============  */
 /* botoes-container */
/* ===============  */
.botoes-container {
  display: flex; /* Habilita o Flexbox */
  margin: 30px 0;
  height: 56px;
  justify-content: center; /* Alinha horizontalmente no centro */
  align-items: flex-start; /* Alinha verticalmente no topo */
  gap: 30px;
}

.botoes-container a {
  flex-direction: column;
  color: #fff;
  text-decoration: none;
  font-size: 18px;
  display: flex;
  align-items: center;
  gap: 4px;
  transition: color 0.3s ease;
}

.botoes-container a svg, .botoes-container a img {
  width: 36px;
  height: 36px;
  fill: currentColor;
}

/* Texto */
.botoes-container span {
  font-size: 15px;
  user-select: none;
}

  /* ===============  */
 /*      Footer      */
/* ===============  */
#main-footer, #preview-footer {
  bottom: 0;
  height: 56px;
  border-top: 1px solid #222;
  justify-content: space-around;
  align-items: center;
}

#main-footer a, #preview-footer a {
  color: #fff;
  text-decoration: none;
  font-size: 12px;
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 4px;
  transition: color 0.3s ease;
}

#main-footer a svg, #preview-footer a img {
  width: 24px;
  height: 24px;
  fill: currentColor;
}

/* Texto do footer */
#main-footer span {
  font-size: 10px;
  user-select: none;
}

/* Adaptativo para telas pequenas */
@media screen and (max-width: 600px) {
  header {
    padding: 0 8px;
  }
  #main-footer a {
    font-size: 8px;
    gap: 2px;
  }
  #main-footer a svg {
    width: 20px;
    height: 20px;
  }
  #preview-footer {
    height: 48px;
  }
}

  /*=================*/
 /* Loading Overlay */
/*=================*/
.loading-overlay {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0, 0, 0, 0.9);
    display: none;
    align-items: center;
    justify-content: center;
    z-index: 9999;
    flex-direction: column;
    gap: 20px;
}

.loading-overlay.active {
    display: flex;
}

.loading-spinner {
    width: 50px;
    height: 50px;
    border: 4px solid #333;
    border-top: 4px solid #6d28d9;
    border-radius: 50%;
    animation: spin 1s linear infinite;
}

.loading-text {
    color: #fff;
    font-size: 16px;
    text-align: center;
}

@keyframes spin {
    0% { transform: rotate(0deg); }
    100% { transform: rotate(360deg); }
}

  /* ======== */
 /* Edit Srt */
/* ======== */
.video-section {
    padding: 20px;
    border-radius: 8px;
}

video {
    width: 100%;
    border-radius: 4px;
}

input, textarea { 
  width: calc(100% - 40px); 
  margin-top: 5px; 
  margin-bottom: 10px; 
  padding: 6px; 
  font-size: 14px; 
}

button { margin: 3px; padding: 6px 10px; font-size: 14px; cursor: pointer; }

.time-controls { display: flex; align-items: center; gap: 5px; }

label { font-weight: bold; display: block; margin-top: 10px; }
  
/* Estilo para o formul√°rio (se voc√™ quiser que os itens fiquem um abaixo do outro) */
form {
  	display: flex;
  	flex-direction: column;
  	gap: 15px; /* Espa√ßo entre cada op√ß√£o */
}

form label {
	font-size: 14px;
}

/* Estilo para cada par de radio + texto */
.radio-option {
  	display: flex;
  	align-items: center; /* Alinha o bot√£o e o texto verticalmente */
  	cursor: pointer;
  	gap: 8px; /* Ajuste este valor para controlar o espa√ßo entre o bot√£o e o texto */
}
  
input[type="radio"] {
    width: 15px;
    height: 15px;
}

/* ================================== */
/* Estilo para a Lista de Legendas */
/* ================================== */
.segmentsArea {
    max-height: 50vh; /* ou a altura que preferir */
    overflow-y: auto;
    width: 100%;
}

.segment { 
  background: white; 
  padding: 10px; 
  border-radius: 10px; 
  margin: 5px 0; 
  cursor: pointer; 
  transition: 0.2s; 
}

.segment:hover:not(.segment-selected) { 
  background: #e7f0ff; 
  transform: scale(1.01); 
}

.segment-selected {
  background: linear-gradient(#AFD9E3, #628FA1 100%) !important;
  color: #0B2A40 !important;
  font-weight: bold !important;
}

/*thumb-section*/
.thumb-section { 
  width: 100%;
  height: auto;
}

.thumb-section img {
  max-height: 400px;
  max-width: 600px;
  width: 100%;
  display: block;
  margin: 0 auto;
}

/* info-content */
.info-content {
  display: flex !important;;
  justify-content: space-between;
  align-items: center;
  margin: 0 10px 8px;
  font-size: 12px;
  max-height: 400px;
  max-width: 600px;
  margin: 0 auto;
}

/* Imagem do canal */
.channel-pic {
  width: 40px;
  height: 40px;
  border-radius: 50%;
  object-fit: cover;
  margin: 1px 0 0 0;
}

/* Texto do v√≠deo */
.video-text {
  flex: 1;
  display: flex;
  flex-direction: column;
}

/* T√≠tulo do v√≠deo */
.video-title {
  font-size: 14px;
  font-weight: 600;
  color: #fff;
  margin: 5px 0 5px 8px;
  text-align: left;
}

/* Linha com nome do canal, desempenho e editar */
.video-meta {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin: 0 0 5px 8px;
  font-size: 14px;
}

/* Nome do canal */
.channel-name {
  color: #bbbbbb;
}

/* Desempenho (percentual) */
.performance {
  color: #4caf50;
  font-weight: bold;
}

/* Bot√£o Editar */
.video-edit {
  color: #6d28d9;
  font-weight: bold;
  cursor: pointer;
  transition: color 0.3s;
}

.video-time {
  position: absolute;
  bottom: 8px;
  right: 8px;
  background: rgba(0,0,0,0.7);
  padding: 2px 6px;
  font-size: 12px;
  border-radius: 4px;
}
</style>
</head>
<body>

  <!-- Loading Overlay -->
  <div id="loadingOverlay" class="loading-overlay">
      <div class="loading-spinner"></div>
      <div class="loading-text" id="loadingText">Carregando...</div>
  </div>
  
  <header>
    <div class="logo-area" onclick="showSection('home')">
      <img src="https://files.catbox.moe/6nkxcx.svg" alt="√çcone SVG" width="30" height="30" />
      <div>PhraseCraft</div>
    </div>
    
    <div class="icons-right">
      <!-- Create -->
      <a href="#" id="icon-create" onclick="showSection('create')" hidden>
        <svg class="icon" viewBox="0 0 24 24">
        <path fill-rule="evenodd" d="M17 10.5V7a1 1 0 0 0-1-1H4a1 1 0 0 0-1 1v10a1 1 0 0 0 1 1h12a1 1 0 0 0 1-1v-3.5l4 4V6.5l-4 4zM11 11V9H9v2H7v2h2v2h2v-2h2v-2h-2z"/>
        </svg>
      </a>
      <!-- Search -->
      <a href="#" onclick="showSection('search')">
        <svg class="icon" viewBox="0 0 24 24"><path d="M21 20l-5.8-5.8A7 7 0 1 0 4 11a7 7 0 0 0 11.2 5.6L21 20zM6 11a5 5 0 1 1 10 0a5 5 0 0 1-10 0z"/></svg>
      </a>
      <!-- Notifications -->
      <a href="#" onclick="showSection('notifications')">
      <svg class="icon" viewBox="0 0 24 24"><path d="M12 22a2.5 2.5 0 0 0 2.5-2.5h-5A2.5 2.5 0 0 0 12 22zm6-6V11c0-3.3-2.2-6-5-6V4a1 1 0 1 0-2 0v1c-2.8 0-5 2.7-5 6v5l-1.9 1.9A1 1 0 0 0 6 20h12a1 1 0 0 0 .9-1.6L18 16z"/></svg>
      </a>
    </div>
  </header>

    <!-- Elementos compartilhados -->
    <video id="shared-video" controls hidden>
      <source src="video.mp4" type="video/mp4" />
      Seu navegador n√£o suporta v√≠deo HTML5.
    </video>

    <div id="shared-text" hidden>Este √© um conte√∫do compartilhado e fixo.</div>

    <img id="shared-image" src="imagem.jpg" alt="Imagem compartilhada" hidden />

  <main>
    <!-- Se√ß√µes -->
    <section id="home">
        <h2>Home</h2>
        <p>Welcome to the home section.</p>
        <div class="post-container" id="home-post-container">
            <!-- Os cards de v√≠deo ser√£o inseridos aqui -->
        	<div id="thumb-section-home"></div>
            <div id="info-content-home"></div>

        </div>
    </section>

    <section id="create">
        <h2>Create</h2>
        <p>Use this section to create new content.</p>
            <div class="load-group">
                <label for="videoUpload" class="upload-btn">Upload V√≠deo</label>
                <input type="text" id="videoUrl" placeholder="Cole a URL do v√≠deo ou fa√ßa o upload">
                <input type="file" id="videoUpload" accept="video/*">
            </div>
            <div class="load-group">
                <label for="srtUpload" class="upload-btn">Upload SRT</label>
                <input type="text" id="srtUrl" placeholder="Cole a URL da legenda (.srt) ou fa√ßa o upload">
                <input type="file" id="srtUpload" accept=".srt">
            </div>

            <div class="botoes-container">
                <button id="btn-open" onclick="openContent();">Continuar üëâ</button>
            </div>
    </section>

    <section id="search">
      <h2>Search</h2>
      <p>Use this section to search content.</p>
    </section>

    <section id="notifications">
      <h2>Notifications</h2>
      <p>Here are your notifications.</p>
    </section>

    <section id="you">
      <h2>You</h2>
      <p>This section is about your profile.</p>
                      
      <div class="botoes-container">
        <a href="#" onclick="showSection('myProfile')">
            <img src="https://files.catbox.moe/r8near.png" alt="√çcone SVG" width="21" height="21" /><span>Meu Perfil</span></a>
        <a href="#" id="btn-myPosts" onclick="showSection('myPosts')">
            <img src="https://files.catbox.moe/48dken.svg" alt="√çcone SVG" width="21" height="21" /><span>Minhas Postagens</span></a>
      </div>
    
    </section>

    <section id="subscriptions">
      <h2>Subscriptions</h2>
      <p>See all your subscriptions here.</p>
    </section>
    
    <!-- Subsections -->
    <section id="login-screen" class="login-screen-container">
        <div class="login-card">
            <h2>Entrar</h2>
            <form id="login-form">
                <input type="email" id="email-login" placeholder="E-mail" required>
                <input type="password" id="password-login" placeholder="Senha" required>
                <p id="login-message"></p>
                <button type="submit" class="login-button">Entrar</button>
            </form>
        </div>
    </section>
    
    <section id="myProfile">
      <h2>My Account</h2>
      <p>Use this section to see and edit your profile.</p>
      <div class="header-content"  id="header-content">
      
        <div class="user-buttons">
            <div id="user-email-display" style="font-size: 0.9em; color: rgba(255, 255, 255, 0.7);"></div>

			<div class="">
				<button id="btnLogin" class="btnLogin" onclick="showSection('login-screen')">Entrar</button><hr>
            	<button id="logout-button" class="" onclick="handleLogout()" >Sair</button>
            </div>
            
        </div>
      </div>
    </section>
    
    <section id="postLesson">
      <h2>Post</h2>
      <p>Use this section to post.</p>
                      
      <div id="postLesson-containerBtn" class="botoes-container">
          <button onclick="showSection('editSrt')">üëà</button>
          <button href="#" onclick="postLesson()">Postar Li√ß√£o ‚¨ÜÔ∏è</button>
      </div>
      
      <div id="video-section-postLesson"></div>
      
      <button id="captureBtn" onclick="handleCaptureClick()">üì∏ Capturar Thumbnail</button>
      
      <div id="thumb-section-postLesson"></div>
      
      <!-- T√≠tulo -->
      <h2>Nome</h2>
      <!-- Input de texto -->
      <input type="text" placeholder="Digite um nome..." name="nome" />
      
      <!-- T√≠tulo -->
      <h2>Descri√ß√£o</h2>
      <!-- Input de texto -->
      <input type="text" placeholder="Digite uma descri√ß√£o..." name="description" />

      <!-- T√≠tulo -->
      <form id="linhaForm">
      	<h2>Adicionar √† Playlist</h2>
        <label class="" for="playlist1">
        <input type="checkbox" id="playlist1" name="playlist" value="Playlist 1" />
        Playlist 1
        </label>
        <label class="" for="playlist2">
        <input type="checkbox" id="playlist2" name="playlist" value="Playlist 2" />
        Playlist 2
        </label>
        <label class="" for="playlist3">
        <input type="checkbox" id="playlist3" name="playlist" value="Playlist 3" />
        Playlist 3
        </label>
      </form>
      
    </section>
    
    <section id="myPosts">
        <h2>My Lessons Posts</h2>
        <p>Use this section to see your lessons posted.</p>
        <div id="user-post-container">
            <!-- Os cards de v√≠deo do usu√°rio ser√£o inseridos aqui -->
        </div>
    </section>

    <section id="challenge" class="">
      <!-- Lobby Area -->
      <div id="lobby">
      	<p>Aguardando oponente...</p>
      </div>
      
      <!-- Criadas -->
      <h2>Partidas Criadas</h2>
      <p>Use this section to see all matches waiting a second player.</p>
    </section>
    
    <!----------->
    <!--editSrt-->
    <!----------->
    <section id="editSrt">
      <div id="save-area">
          <span id="btn-close" onclick="closeLoadSaveArea()">&times;</span>
          <p>üíæ Salvar</p>
          <div class="btn-container">
              <button onclick="copyToClipboard()">üìã Copiar</button>
              <button onclick="downSrt()">‚¨áÔ∏è Download</button>
              <button onclick="showSRT()">üßæ Exibir</button>
          </div>
      </div><!--save-area-->
      
      <!-- Div para exibir o nome do arquivo da legenda -->
      <div id="subtitleName"></div>
        
      <div id="video-section-editor"></div>
      
      <div id="navigation-controls-previewMode"></div>

      <div class="" id="editor">
        <label>In√≠cio</label>
        <div class="time-controls">
          <input id="editStart">
          <button onclick="adjustTime('start',  -TIME_STEP)">‚àí</button>
          <button onclick="adjustTime('start', +TIME_STEP)">+</button>

          <button onclick="undo()">‚Ü©</button>
          <button onclick="redo()">‚Ü™</button>
        </div>

        <label>Fim</label>
        <div class="time-controls">
          <input id="editEnd">
          <button onclick="adjustTime('end', -TIME_STEP)">‚àí</button>
          <button onclick="adjustTime('end', +TIME_STEP)">+</button>

          <button onclick="addSegment()">‚ò∞ ‚ûïÔ∏è</button>
          <button onclick="removeSegment()">‚ò∞ ‚ûñ</button>
        </div>

        <label>Texto</label>
        <textarea id="editText" rows="3"></textarea>

        <button id="btn-save" onclick="showSave()">üíæ</button>
        <button onclick="prevLine()">‚óÄ‚óÄ</button>
        <button onclick="playLine()">‚ñ∂</button>
        <button onclick="nextLine()">‚ñ∂‚ñ∂</button>
        <button id="btn-load" onclick="showSection('postLesson')">üëâ</button>

        <p id="btn-config" onclick="showConfig()">‚öô Editar em Lote</p>

        <div id="config-area">
            <span id="btn-close" onclick="closeLoadSaveArea()">&times;</span>
            <div class="time-controls">
              <input id="editStack" placeholder="0.05">
              <button onclick="showEarlier()">Adiantar</button>
              <button onclick="showLater()">Atrasar</button>
            </div>

            <form id="linhaForm">
              <label class="radio-option">
                <input type="radio" name="opcao-linha" value="all" checked>
                Todas as linhas
              </label>
              <label class="radio-option">
                <input type="radio" name="opcao-linha" value="current">
                Apenas linha atual
              </label>

              <label class="radio-option">
                <input type="radio" name="opcao-linha" value="from-current">
                Linha selecionada e pr√≥ximas linhas
              </label>
            </form>
            <hr>
        </div>
      </div><!--editor-->

      <div class="segmentsArea" id="segments-area">
      	  <label>Lista de Legendas</label>
          <div id="segments"></div>
      </div>
    </section>

	<section id="play" class="content-row">
		<div id="performance"></div>
		<div id="video-section-play"></div>

      	<div id="buttons">
      		<button id="repetir" class="control-button" style="background: linear-gradient(to bottom, #b34dd6 0%, #9C27B0 50%, #7c1f8e 100%);">Tocar Trecho</button>
      		<button id="lerFrase" class="control-button" style="background: linear-gradient(to bottom, #78c0ff 0%, #5babf0 50%, #4d98e5 100%);">Tocar Lento</button>
      		<button id="traduzir-btn" class="control-button" style="background: linear-gradient(to bottom, #ffc078 0%, #ffa94d 50%, #e59442 100%);">Traduzir</button>
      		<button id="desistir" class="control-button" style="background: linear-gradient(to bottom, #ff5e91 0%, #E91E63 50%, #c41858 100%);">Passar</button>
		</div>

		<div class="phrase-container" id="frase"></div>

        <div class="word-button-wrapper">
            <div class="word-container" id="palavras"></div>
        </div>
        
        <div id="progresso" style="margin-top: 10px; font-size: 0.9em;">Progresso: 0 de 0</div>
    </section>
  </main>  

  <footer id="main-footer">
    <a href="#" onclick="showSection('home')">
      <svg viewBox="0 0 24 24"><path d="M12 3.3l8 6V20a1 1 0 0 1-1 1h-5v-6H10v6H5a1 1 0 0 1-1-1V9.3l8-6z"/></svg>
      <span>Home</span>
    </a>
    <a href="#" onclick="showSection('subscriptions')">
      <svg viewBox="0 0 24 24"><path d="M17 10.5V7a1 1 0 0 0-1-1H4a1 1 0 0 0-1 1v10a1 1 0 0 0 1 1h12a1 1 0 0 0 1-1v-3.5l4 4V6.5l-4 4z"/></svg>
      <span>Subscriptions</span>
    </a>
    <a href="#" onclick="showSection('you')">
        <img src="https://files.catbox.moe/p2znlg.svg" alt="√çcone SVG" width="21" height="21" /><span>You</span></a>
    <a href="#" onclick="showSection('challenge')">
        <img src="https://files.catbox.moe/tdzklr.svg" alt="√çcone SVG" width="25" height="25" /><span>Desafios</span></a>
  </footer>

  <footer id="preview-footer" style="display: none;">
    <a href="#" onclick="startSoloMode()">
        <img src="https://files.catbox.moe/p2znlg.svg" alt="√çcone SVG" width="21" height="21" /><span>Solo</span></a>
    <a href="#" onclick="startMultiMode()">
        <img src="https://files.catbox.moe/tdzklr.svg" alt="√çcone SVG" width="25" height="25" /><span>Desafiar</span></a>
  </footer>

<script>
let showVideoArea = true;
let showEditorArea = true;
let showSegmentsArea = true;
let showSaveArea = false;
let showLoadArea = false;
let showConfigArea = false;
let showLobbyArea = false;
let showPreviewMode = false;

// Vari√°veis do Editor SRT
let srtData = [];
let currentSegment = null;
let undoStack = [];
let redoStack = [];
let subtitleName = "";
let stopTimeout = null;
let isBatchEditing = false;
const TIME_STEP = 0.1;

/**
 * Array para armazenar as palavras selecionadas na ordem
 */
let selectedWords = [];

/**
 * Vari√°vel para controlar o √≠ndice do segmento atual
 */
let currentSegmentIndex = 0;

/**
 * Inicia o modo solo
 */
function startMultiMode() {
  console.log("=== IN√çCIO startSoloMode() ===");
  showSection('challenge');
  showLobbyArea = true;
  
  renderPage();    
}

// ‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò
// --- Bloco Fx | Performance --- 
// ‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò

// Vari√°veis de performance
// Vari√°veis de performance
const TIME_PER_LETTER = 0.15; // segundos por letra (ajust√°vel)
let segmentStartTime = null;
let totalProjectedTime = 0;
let performanceUpdateInterval = null;

/**
 * Inicia o cron√¥metro do segmento
 */
function startSegmentTimer() {
  const currentSegment = srtData[currentSegmentIndex];
  
  if (!currentSegment) return;
  
  // Conta total de letras na frase
  const totalLetters = currentSegment.text.replace(/\s+/g, '').length;
  
  // Calcula tempo projetado
  totalProjectedTime = totalLetters * TIME_PER_LETTER;
  
  // Marca o tempo de in√≠cio
  segmentStartTime = Date.now();
  
  // Inicia atualiza√ß√£o cont√≠nua da performance (a cada 100ms)
  if (performanceUpdateInterval) {
    clearInterval(performanceUpdateInterval);
  }
  
  performanceUpdateInterval = setInterval(() => {
    updatePerformanceDisplay();
  }, 100); // Atualiza 10x por segundo
  
  console.log(`‚è±Ô∏è Timer iniciado: ${totalLetters} letras = ${totalProjectedTime.toFixed(2)}s projetados`);
}

/**
 * Para o cron√¥metro de performance
 */
function stopSegmentTimer() {
  if (performanceUpdateInterval) {
    clearInterval(performanceUpdateInterval);
    performanceUpdateInterval = null;
    console.log('‚èπÔ∏è Timer parado');
  }
}

/**
 * Atualiza o display de performance em tempo real
 */
function updatePerformanceDisplay() {
  const performanceElement = document.getElementById('host-performance');
  
  // Para se n√£o estivermos na se√ß√£o play
  if (!performanceElement || !segmentStartTime) return;
  
  const currentSegment = srtData[currentSegmentIndex];
  if (!currentSegment) return;
  
  // Obt√©m dados do progresso
  const wordsCompleted = selectedWords.length;
  const totalWords = currentSegment.text.split(/\s+/).filter(w => w.trim().length > 0).length;
  const elapsedTime = (Date.now() - segmentStartTime) / 1000; // segundos
  
  // Calcula o tempo projetado total baseado na velocidade atual
  let projectedTotalTime;
  
  if (wordsCompleted > 0) {
    // Calcula tempo m√©dio por palavra at√© agora
    const avgTimePerWord = elapsedTime / wordsCompleted;
    const remainingWords = totalWords - wordsCompleted;
    projectedTotalTime = elapsedTime + (remainingWords * avgTimePerWord);
  } else {
    // Se nenhuma palavra foi completada, usa uma estimativa inicial
    projectedTotalTime = elapsedTime * totalWords;
  }
  
  // Calcula a performance (tempo ideal / tempo projetado) * 100
  let performanceScore = (totalProjectedTime / projectedTotalTime) * 100;
  
  // Sanitiza valores inv√°lidos
  if (!isFinite(performanceScore) || performanceScore > 1000) {
    performanceScore = 100;
  }
  
  // Escolhe emoji baseado na performance
  let emoji = 'üëç'; // Padr√£o: bom
  if (performanceScore < 75) emoji = 'üê¢';      // Lento
  else if (performanceScore < 100) emoji = 'ü§î'; // M√©dio
  else if (performanceScore > 125) emoji = 'üöÄ'; // Excelente
  
  // Define a cor baseada na performance
  let color = '#4caf50'; // Verde (bom)
  if (performanceScore < 80) color = '#ff9800'; // Laranja (m√©dio)
  if (performanceScore < 60) color = '#f44336'; // Vermelho (baixo)
  if (performanceScore > 125) color = '#00e676'; // Verde brilhante (excelente)
  
  // Atualiza o display
  performanceElement.innerHTML = `
    <span style="font-weight: bold; color: ${color};">
      ${performanceScore.toFixed(1)}%
    </span> ${emoji}
  `;
  
  performanceElement.style.cssText = `
    font-size: 24px;
    text-align: center;
    margin: 20px 0;
    transition: color 0.3s ease;
  `;
  
  console.log(`üìä Performance: ${performanceScore.toFixed(1)}% | Palavras: ${wordsCompleted}/${totalWords} | Tempo: ${elapsedTime.toFixed(1)}s`);
}

// ‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò
// --- Bloco Fx | Cache de Li√ß√µes --- 
// ‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò

const lessonCache = new Map();
const CACHE_EXPIRY = 24 * 60 * 60 * 1000; // 24 horas

function isCacheValid(fileId) {
  if (!lessonCache.has(fileId)) return false;
  
  const cached = lessonCache.get(fileId);
  const now = Date.now();
  
  if (now - cached.timestamp > CACHE_EXPIRY) {
    console.log(`‚è∞ Cache expirado para: ${fileId}`);
    lessonCache.delete(fileId);
    return false;
  }
  
  return true;
}

async function saveLessonToCache(fileId, videoFile, srtFile, thumb) {
  console.log("--- Salvando li√ß√£o no cache ---");
  
  try {
    const videoUrl = getBackblazePublicUrl(videoFile.fileId);
    const videoResponse = await fetch(videoUrl);
    const videoBlob = await videoResponse.blob();
    
    const srtUrl = getBackblazePublicUrl(srtFile.fileId);
    const srtResponse = await fetch(srtUrl);
    const srtContent = await srtResponse.text();
    
    lessonCache.set(fileId, {
      videoBlob: videoBlob,
      srtContent: srtContent,
      videoFileName: videoFile.fileName,
      srtFileName: srtFile.fileName,
      thumbUrl: getBackblazePublicUrl(thumb.fileId),
      timestamp: Date.now()
    });
    
    console.log(`‚úÖ Li√ß√£o salva no cache: ${fileId}`);
  } catch (error) {
    console.error("‚ùå Erro ao salvar no cache:", error);
    throw error;
  }
}

function loadLessonFromCache(fileId) {
  if (!isCacheValid(fileId)) return null;
  return lessonCache.get(fileId);
}

function loadVideoFromCache(videoBlob, fileName) {
  const videoElement = document.getElementById('videoPlayer');
  if (!videoElement) throw new Error('videoPlayer n√£o encontrado');
  
  const blobUrl = URL.createObjectURL(videoBlob);
  videoElement.src = blobUrl;
  console.log(`‚úÖ V√≠deo do cache carregado: ${fileName}`);
}

// ‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò
// GERENCIAMENTO DE SE√á√ïES 
// ‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò

// Lista de elementos com condi√ß√µes
const elements = [
  {
    id: "lobby",
    content: ``,
    condition: () => showLobbyArea
  },
  {
    id: "video-content",
    content: `
	<video id="videoPlayer" controls>
			<source src="http://commondatastorage.googleapis.com/gtv-videos-bucket/sample/BigBuckBunny.mp4" type="video/mp4">
	</video>
    `,
    condition: () => showVideoArea
  },
  {
    id: "thumb-content",
    className: "thumb-section",
    content: `
	<img src="https://files.catbox.moe/bt6lnl.jpg" alt="Preview da Thumbnail">
    `,
    condition: () => showVideoArea
  },
  {
    id: "info-content",
    className: "info-content",
    content: `
		<div class="channel-pic">
			<img src="https://files.catbox.moe/bt6lnl.jpg" alt="Canal" class="channel-pic">
		</div>
        
		<div class="video-text">
			<h3 class="video-title" onclick="previewLesson()" style="cursor: pointer;">{post.videoName}</h3>
			<div class="video-meta">
				<span class="channel-name">channel-name</span>
				<span class="performance">95%</span>
				<span class="video-edit" onclick="event.stopPropagation();" style="cursor: pointer; color: #6d28d9; font-weight: bold;">Editar</span>
    	    </div>
    	</div>
    `,
    condition: () => true
  },
  {
    id: "editor",
    content: `
    
    `,
    condition: () => showEditorArea
  },
  {
    id: "segments-area",
    content: ``,
    condition: () => showSegmentsArea
  },
  {
    id: "navigation-controls",
    content: `
    <button onclick="prevLine()">‚óÄ‚óÄ</button>
    <button onclick="playLine()">‚ñ∂</button>
    <button onclick="nextLine()">‚ñ∂‚ñ∂</button>
    `,
    condition: () => showPreviewMode
  },
  {
    id: "save-area",
    content: "", 
    condition: () => showSaveArea
  },
  {
    id: "load-area",
    content: "",
    condition: () => showLoadArea
  },
  {
    id: "config-area",
    content: "",
    condition: () => showConfigArea
  },
  {
¬† ¬† id: "main-footer",
¬† ¬† content: "", // J√° existe no HTML
¬† ¬† displayType: "flex", // O display que ele deve ter quando vis√≠vel
¬† ¬† condition: () => {// REGRA 1: Esconder se o modo preview estiver ativo
      // REGRA 1: Esconder se o modo preview estiver ativo
      if (showPreviewMode) {
          return false;
      }
¬† ¬† ¬† const activeEl = document.querySelector('section.active');
¬† ¬† ¬† if (!activeEl) return true; // Padr√£o: mostrar
¬† ¬† ¬† const id = activeEl.id;
¬† ¬† ¬† const noFooterSections = ['editSrt', 'login-screen', 'postLesson'];
¬† ¬† ¬† const previewSections = ['play'];
¬† ¬† ¬† 
¬† ¬† ¬† // Mostrar apenas se N√ÉO estiver nas listas de ocultar ou preview
¬† ¬† ¬† return !noFooterSections.includes(id) && !previewSections.includes(id);
¬† ¬† }
¬† },
¬† {
¬† ¬† id: "preview-footer",
¬† ¬† content: "", // J√° existe no HTML
¬† ¬† displayType: "flex", // O display que ele deve ter quando vis√≠vel
¬† ¬† condition: () => {
    	// Mostra APENAS se a vari√°vel showPreviewMode for true.
        return showPreviewMode;
        
        const activeEl = document.querySelector('section.active');
        const id = activeEl.id;
¬† ¬† ¬† 	const noFooterSections = ['home', 'login-screen', 'postLesson'];
¬† ¬† ¬† 	return !noFooterSections.includes(id) && !previewSections.includes(id);
¬† ¬† }
¬† },
  {
    id: "host-performance",
    content: "",
    condition: () => true
  },
];

// Lista de sections com condi√ß√µes
const sections = [
  { id: "home", condition: () => true },
  { id: "search", condition: () => true },
  { id: "notifications", condition: () => true },
  { id: "you", condition: () => true },
  { id: "subscriptions", condition: () => true },
  { id: "create", condition: () => true },
  { id: "postLesson", condition: () => true },
  { id: "editSrt", condition: () => true },
  { id: "myProfile", condition: () => true },
  { id: "myPosts", condition: () => true },
  { id: "login-screen", condition: () => true },
  { id: "play", condition: () => true },
  { id: "challenge", condition: () => true },
];

// Lista de posi√ß√µes para elementos compartilhados (podem aparecer em v√°rias se√ß√µes)
// Far√° com que o script injete o elmento no container/div correto quando a se√ß√£o estiver ativa
const positions = [
  { key: "video-content", after: ["video-section-editor", "video-section-postLesson", "video-section-play"] },
  { key: "thumb-content", after: ["thumb-section-home", "thumb-section-postLesson"] },
  { key: "info-content", after: ["info-content-home"] },
  { key: "navigation-controls", after: ["navigation-controls-previewMode"] },
  { key: "host-performance", after: ["performance"] },
];

// Renderiza se√ß√µes e elementos
function renderPage() {
  // Encontra a se√ß√£o ativa
  const activeSection = document.querySelector('section.active');
  if (!activeSection) return;

  // Renderiza elementos posicionados (l√≥gica original mantida)
  elements.forEach(element => {
    const shouldShow = element.condition();
    if (!shouldShow) {
      // Se n√£o deve mostrar, esconde o elemento se existir
      const existing = document.getElementById(element.id);
      if (existing) existing.style.display = 'none';
      return;
    }

    const pos = positions.find(p => p.key === element.id);
¬† ¬† if (!pos) {
¬† ¬† ¬† // Se n√£o tem posi√ß√£o definida, apenas controla visibilidade
¬† ¬† ¬† const existing = document.getElementById(element.id);
¬† ¬† ¬† if (existing) {
¬† ¬† ¬† ¬† // Usa a displayType espec√≠fica do elemento, ou 'block' como padr√£o
¬† ¬† ¬† ¬† existing.style.display = element.displayType || 'block';¬†
¬† ¬† ¬† }
¬† ¬† ¬† return;
¬† ¬† }

    // Procura o container correto dentro da se√ß√£o ativa
    let container = null;
    for (const targetId of pos.after) {
      const candidate = activeSection.querySelector(`#${targetId}`);
      if (candidate) {
        container = candidate;
        break;
      }
    }
    if (!container) return;

    let existing = document.getElementById(element.id);
    if (!existing) {
      const div = document.createElement('div');
  
      // Aplica a classe na div injetada
      if (element.className) {
        div.className = element.className;
      }
      
      div.id = element.id;
      div.innerHTML = element.content;
      container.appendChild(div);
    } else {
      container.appendChild(existing);
      existing.style.display = "block";
    }
  });
}

// Bot√£o para mostrar/ocultar se√ß√µes
function showSection(sectionId) {
  // ================================================
¬† // <<< Lista de flags para resetar ao mudar de section >>>
¬† showPreviewMode = false;
  showLobbyArea = false;
  
  // Para o timer de performance ao sair da se√ß√£o play
  if (sectionId !== 'play') {
    stopSegmentTimer();
  }
¬† // ================================================
  const section = sections.find(s => s.id === sectionId);
  
  // Se a se√ß√£o n√£o existe ou a condi√ß√£o dela √© falsa, n√£o fa√ßa nada
  if (!section || !section.condition()) {
    return; // Sai da fun√ß√£o sem alterar nada
  }
  
  sections.forEach(s => {
    const el = document.getElementById(s.id);
    if (el) el.classList.remove("active");
  });
  
  const target = document.getElementById(sectionId);
  if (target) target.classList.add("active");
  
  renderPage();
}

// ‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò
// ----- Bloco Fx | Login ----- 
// ‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò

// Configura√ß√£o do Appwrite
const client = new Appwrite.Client()
        .setEndpoint('https://nyc.cloud.appwrite.io/v1')
        .setProject('68ebe8640000ca7c860b');

const account = new Appwrite.Account(client);

// Seletores de elementos HTML (TODOS JUNTOS AQUI)

const btnLoginHeader = document.getElementById('btnLogin');

const loginForm = document.getElementById('login-form');
const logoutButton = document.getElementById('logout-button');
const userEmailDisplay = document.getElementById('user-email-display');
const iconCreate = document.getElementById('icon-create');
const btnMyPosts = document.getElementById('btn-myPosts');

const loginMessage = document.getElementById('login-message');

// Fun√ß√£o para verificar o status de login
let isCheckingAuth = false;

async function checkAuthStatus() {
    // Verifica se j√° h√° uma sess√£o em cache
    const cachedEmail = localStorage.getItem('userEmail');
    if (cachedEmail) {
        renderUIForAuthState(true, cachedEmail);
        showSection('myPosts');
        return;
    }
    
    showLoading('Carregando...');
    console.log('Verificando sess√£o...')
    
    try {
        const user = await account.get();
        // Salva o email no cache
        localStorage.setItem('userEmail', user.email);
        renderUIForAuthState(true, user.email);
        showSection('myPosts');
    } catch (error) {
    	console.log('Usu√°rio n√£o est√° logando. Direcinando para "home"...')
        // Remove cache se houver erro
        localStorage.removeItem('userEmail');
        renderUIForAuthState(false);
        showSection('home');
    } finally {
        hideLoading();
    }
}
    
// Evento de submiss√£o do formul√°rio de login
loginForm.addEventListener('submit', async (e) => {
    e.preventDefault();
    const email = document.getElementById('email-login').value;
    const password = document.getElementById('password-login').value;
    loginMessage.textContent = '';
    
    showLoading('Entrando...');
    
    try {
        // Primeiro tenta deletar qualquer sess√£o existente
        try {
            await account.deleteSession('current');
        } catch (error) {
            // Ignora erro se n√£o houver sess√£o ativa
        }
        
        // Agora cria a nova sess√£o
        await account.createEmailPasswordSession(email, password);
        
        // Atualiza a interface
        const user = await account.get();
        // Salva no cache
        localStorage.setItem('userEmail', user.email);
        renderUIForAuthState(true, user.email);
        showSection('myPosts');
    } catch (error) {
        loginMessage.textContent = 'Erro no login: ' + error.message;
    } finally {
        hideLoading();
    }
});

// Fun√ß√£o de logout
function handleLogout() {
    showLoading('Saindo...');
    
    account.deleteSession('current')
        .then(() => {
            localStorage.removeItem('userEmail');
            renderUIForAuthState(false);
            showSection('home');
        })
        .catch((error) => {
            console.error('Erro ao fazer logout:', error);
        })
        .finally(() => {
            hideLoading();
        });
}
    
/* Fun√ß√£o para renderizar a interface de
    ** acordo com o estado de autentica√ß√£o */
function renderUIForAuthState(isLoggedIn, userEmail = '') {
    // Esconde tudo primeiro
    iconCreate.style.display = 'none';
    btnMyPosts.style.display = 'none';
    btnLoginHeader.style.display = 'none';
    logoutButton.style.display = 'none';
    userEmailDisplay.style.display = 'none';
    
    // Garantir que a tela de login seja escondida
    document.getElementById('login-screen').classList.remove('active');

    if (isLoggedIn) {
        // Mostra email e bot√£o sair
        userEmailDisplay.textContent = userEmail;
        userEmailDisplay.style.display = 'block';
        logoutButton.style.display = 'block';
    	iconCreate.style.display = 'block';
	    btnMyPosts.style.display = 'flex';
    } else {
        // Mostra apenas bot√£o entrar
        btnLoginHeader.style.display = 'block';
    }
}

// Fun√ß√£o para mostrar perfil ou tela de login
async function showProfile() {
    try {
        const user = await account.get();
        // Se conseguiu pegar o usu√°rio, est√° logado
        showSection('myProfile');
    } catch (error) {
        // Se deu erro, n√£o est√° logado
        showSection('login-screen');
    }
}

checkAuthStatus();

// ‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò
// ----- Bloco Fx | Loading ----- 
// ‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò

let isLoading = false;

function showLoading(message = 'Carregando...') {
    const overlay = document.getElementById('loadingOverlay');
    const text = document.getElementById('loadingText');
    if (text) text.textContent = message;
    if (overlay) overlay.classList.add('active');
    isLoading = true;
}

function hideLoading() {
    const overlay = document.getElementById('loadingOverlay');
    if (overlay) overlay.classList.remove('active');
    isLoading = false;
}

// Inicializa
document.addEventListener("DOMContentLoaded", () => {
  renderPage();
  showSection("home");
  loadAndDisplayThumbnails();
});

// ‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò
// ----- Bloco Fx | Edit Srt ----- 
// ‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò
function showSave() {
    showVideoArea = false;
    showEditorArea = false;
    showSegmentsArea = false;
    showLoadArea = false;
    showSaveArea = true;
    showConfigArea = false;
    renderPage();
}

function closeLoadSaveArea() {
    showVideoArea = true;
	showEditorArea = true;
    showSegmentsArea = true;
    showSaveArea = false;
    showLoadArea = false;
    showConfigArea = false;
    renderPage();
}

function showConfig() {
    showConfigArea = true;
    showSaveArea = false;
    showLoadArea = false;
    renderPage();
}


function renderSegments() {
  const container = document.getElementById("segments");
  container.innerHTML = "";  // Limpa a lista de segmentos

  srtData.forEach(seg => {
    const div = document.createElement("div");
    div.className = "segment";
    div.setAttribute('data-id', seg.id);
    
    // Adiciona classe ao segmento selecionado
    if (seg.id === currentSegment?.id) {
      div.classList.add("segment-selected");
    }
    
    // Define o conte√∫do do segmento
    div.innerHTML = `<b>${seg.id}</b> [${seg.start} ‚Üí ${seg.end}]<br>${seg.text}`;
    
    // Define a a√ß√£o de clicar no segmento
    div.onclick = () => openEditor(seg.id);
    
    // Adiciona o segmento ao container
    container.appendChild(div);
  });
}

function openEditor(id) {
  currentSegment = srtData.find(s => s.id === id);
  if (!currentSegment) return;

  // S√≥ mostra o editor se N√ÉO estivermos no modo preview
  if (!showPreviewMode) { 
¬† ¬† document.getElementById("editor").style.display = "block";
¬† }
  
  document.getElementById("editStart").value = currentSegment.start;
  document.getElementById("editEnd").value = currentSegment.end;
  document.getElementById("editText").value = currentSegment.text;

  document.getElementById("editStart").oninput = e => handleChange("start", e.target.value);
  document.getElementById("editEnd").oninput = e => handleChange("end", e.target.value);
  document.getElementById("editText").oninput = e => handleChange("text", e.target.value);
  
  // Remove a classe de todos os segmentos
  document.querySelectorAll('.segment').forEach(item => {
    item.classList.remove('segment-selected');
  });
  
  // Adiciona a classe apenas ao segmento atual
  const itemAtivo = document.querySelector(`[data-id="${id}"]`);
  if (itemAtivo) {
    itemAtivo.classList.add('segment-selected');
  }
  
  scrollToSegment(id);
  
  setTimeout(() => playLine(), 500);
}

function handleChange(field, newValue) {
  if (!currentSegment) return;
  const oldValue = currentSegment[field];
  if (oldValue === newValue) return;

  // Cria uma c√≥pia profunda do segmento ANTES da mudan√ßa
  const oldSegment = { ...currentSegment };
  
  undoStack.push({ 
    type: "edit",
    id: currentSegment.id, 
    field, 
    oldValue, 
    newValue,
    segmentBackup: oldSegment // backup completo do segmento
  });
  redoStack = [];
  currentSegment[field] = newValue;
  renderSegments();
}

function adjustTime(field, deltaSeconds) {
  if (!currentSegment) return;

  const oldValue = currentSegment[field];
  const newValue = shiftTime(oldValue, deltaSeconds);

  const idx = srtData.findIndex(s => s.id === currentSegment.id);
  const prev = srtData[idx - 1];
  const next = srtData[idx + 1];

  const toMs = t => {
    const [h, m, rest] = t.split(":");
    const [s, ms] = rest.split(",");
    return (+h * 3600 + +m * 60 + +s) * 1000 + +ms;
  };

  const newMs = toMs(newValue);
  const startMs = toMs(currentSegment.start);
  const endMs = toMs(currentSegment.end);

  if (field === "start" && prev && newMs <= toMs(prev.end) + 0) return;
  if (field === "end" && next && newMs >= toMs(next.start) - 0) return;
  if (field === "start" && newMs >= endMs - 0) return;
  if (field === "end" && newMs <= startMs + 0) return;
  
  // Cria uma c√≥pia profunda do segmento ANTES da mudan√ßa
  const oldSegment = { ...currentSegment };
  
  if (!isBatchEditing) {
    undoStack.push({ 
      type: "edit",
      id: currentSegment.id, 
      field, 
      oldValue, 
      newValue,
      segmentBackup: oldSegment
    });
    redoStack = [];
  }

  redoStack = [];

  currentSegment[field] = newValue;
  updateEditorFields(currentSegment);
  renderSegments();
}

function shiftTime(timeStr, delta) {
  // "00:00:04,500" ‚Üí soma delta (em segundos)
  const [h, m, rest] = timeStr.split(":");
  const [s, ms] = rest.split(",");
  let totalMs = (+h * 3600 + +m * 60 + +s) * 1000 + +ms + delta * 1000;

  if (totalMs < 0) totalMs = 0;
  const hours = Math.floor(totalMs / 3600000);
  const minutes = Math.floor((totalMs % 3600000) / 60000);
  const seconds = Math.floor((totalMs % 60000) / 1000);
  const millis = Math.floor(totalMs % 1000);
  return `${pad(hours)}:${pad(minutes)}:${pad(seconds)},${pad(millis, 3)}`;
}

function pad(num, size=2) {
  return num.toString().padStart(size, "0");
}

// ======================
// ‚Ü© | ‚Ü™ | ‚ò∞ ‚ûñ | ‚ò∞ ‚ûïÔ∏è
// ======================
function undo() {
  if (!undoStack.length) return;
  const last = undoStack.pop();
  redoStack.push(last);

  if (last.type === "add") {
    // Restaura o array completo de antes da adi√ß√£o
    srtData.length = 0;
    srtData.push(...last.stateBefore.map(s => ({...s})));
    currentSegment = srtData[last.currentIndex] || srtData[last.currentIndex - 1] || null;
  } else if (last.type === "remove") {
    // Restaura o array completo de antes da remo√ß√£o
    srtData.length = 0;
    srtData.push(...last.stateBefore.map(s => ({...s})));
    currentSegment = srtData.find(s => s.id === last.segment.id) || null;
  } else if (last.type === "edit") {
    const seg = srtData.find(s => s.id === last.id);
    if (seg) {
      seg[last.field] = last.oldValue;
      currentSegment = seg;
    }
  } else if (last.type === "edit-multiple") {
    srtData.length = 0;
    srtData.push(...last.stateBefore.map(s => ({ ...s })));
    currentSegment = srtData.find(s => s.id === currentSegment?.id) || srtData[0] || null;
  }


  renderSegments();
  if (currentSegment) updateEditorFields(currentSegment);
}

function redo() {
  if (!redoStack.length) return;
  const last = redoStack.pop();
  undoStack.push(last);

  if (last.type === "add") {
    // Restaura o array completo de depois da adi√ß√£o
    srtData.length = 0;
    srtData.push(...last.stateAfter.map(s => ({...s})));
    currentSegment = srtData.find(s => s.id === last.segment.id) || null;
  } else if (last.type === "remove") {
    // Restaura o array completo de depois da remo√ß√£o
    srtData.length = 0;
    srtData.push(...last.stateAfter.map(s => ({...s})));
    currentSegment = srtData[last.currentIndex] || srtData[last.currentIndex - 1] || null;
  } else if (last.type === "edit") {
    const seg = srtData.find(s => s.id === last.id);
    if (seg) {
      seg[last.field] = last.newValue;
      currentSegment = seg;
    }
  } else if (last.type === "edit-multiple") {
    srtData.length = 0;
    srtData.push(...last.stateAfter.map(s => ({ ...s })));
    currentSegment = srtData.find(s => s.id === currentSegment?.id) || srtData[0] || null;
  }

  renderSegments();
  if (currentSegment) updateEditorFields(currentSegment);
}

function addSegment() {
  // Salva o estado ANTES da modifica√ß√£o
  const stateBefore = srtData.map(s => ({...s}));
  
  let insertIndex = srtData.length;
  if (currentSegment) {
    const idx = srtData.findIndex(s => s.id === currentSegment.id);
    insertIndex = idx + 1;
  }

  const newId = insertIndex + 1;
  const newSegment = {
    id: newId,
    start: "00:00:00,000",
    end: "00:00:00,000",
    text: "Novo trecho"
  };
  
  srtData.splice(insertIndex, 0, newSegment);
  
  // Renumera os IDs a partir do ponto de inser√ß√£o
  for (let i = insertIndex + 1; i < srtData.length; i++) {
    srtData[i].id = i + 1;
  }

  // Salva o estado DEPOIS da modifica√ß√£o
  const stateAfter = srtData.map(s => ({...s}));

  undoStack.push({
    type: "add",
    segment: { ...newSegment },
    stateBefore: stateBefore,
    stateAfter: stateAfter,
    currentIndex: insertIndex
  });
  redoStack = [];

  currentSegment = newSegment;
  renderSegments();
  openEditor(currentSegment.id);
}

function removeSegment() {
  if (!currentSegment) return;
  if (srtData.length === 1) return alert("N√£o √© poss√≠vel remover o √∫nico segmento.");

  // Salva o estado ANTES da modifica√ß√£o
  const stateBefore = srtData.map(s => ({...s}));
  
  const idx = srtData.findIndex(s => s.id === currentSegment.id);
  const removedSegment = { ...srtData[idx] };
  srtData.splice(idx, 1);

  // Renumera os IDs ap√≥s a remo√ß√£o
  for (let i = idx; i < srtData.length; i++) {
    srtData[i].id = i + 1;
  }

  // Salva o estado DEPOIS da modifica√ß√£o
  const stateAfter = srtData.map(s => ({...s}));

  undoStack.push({
    type: "remove",
    segment: removedSegment,
    stateBefore: stateBefore,
    stateAfter: stateAfter,
    currentIndex: idx
  });
  redoStack = [];

  currentSegment = srtData[idx] || srtData[idx - 1] || null;

  renderSegments();
  if (currentSegment) openEditor(currentSegment.id);
  else document.getElementById("editor").style.display = "none";
}

function updateEditorFields(seg) {
  document.getElementById("editStart").value = seg.start;
  document.getElementById("editEnd").value = seg.end;
  document.getElementById("editText").value = seg.text;
}

document.addEventListener("keydown", e => {
  if (e.ctrlKey && e.key === "z") { e.preventDefault(); undo(); }
  if (e.ctrlKey && e.key === "y") { e.preventDefault(); redo(); }
});


// ======================
// ‚óÄ‚óÄ | ‚ñ∂‚ñ∂
// ======================
function prevLine() {
  if (!currentSegment) return;
  
  // Limpa timeout e pausa o v√≠deo ANTES de trocar de linha
  if (stopTimeout) {
    clearTimeout(stopTimeout);
    stopTimeout = null;
  }
  
  const videoElement = document.getElementById("videoPlayer");
  if (videoElement && !videoElement.paused) {
    videoElement.pause();
  }
  
  const idx = srtData.findIndex(s => s.id === currentSegment.id);
  if (idx > 0) {
    openEditor(srtData[idx - 1].id);
    scrollToSegment(srtData[idx - 1].id);
  }
}

function nextLine() {
  if (!currentSegment) return;
  
  // Limpa timeout e pausa o v√≠deo ANTES de trocar de linha
  if (stopTimeout) {
    clearTimeout(stopTimeout);
    stopTimeout = null;
  }
  
  const videoElement = document.getElementById("videoPlayer");
  if (videoElement && !videoElement.paused) {
    videoElement.pause();
  }
  
  const idx = srtData.findIndex(s => s.id === currentSegment.id);
  if (idx < srtData.length - 1) {
    openEditor(srtData[idx + 1].id);
    scrollToSegment(srtData[idx + 1].id);
  }
}

function scrollToSegment(id) {
  const segmentsContainer = document.getElementById("segments-area");
  const segments = document.querySelectorAll(".segment");
  
  // Encontra o elemento do segmento pelo √≠ndice (id - 1)
  const targetSegment = segments[id - 1];
  
  if (targetSegment && segmentsContainer) {
    // Usando scrollIntoView para centralizar o segmento
    targetSegment.scrollIntoView({
      behavior: 'smooth',  // Anima√ß√£o suave
      block: 'center'      // Centraliza verticalmente
    });
  }
}

// ======================
// Etidar e lote
// ======================
function showEarlier() {
  shiftSelectedLines(-getCurrentStep());
}

function showLater() {
  shiftSelectedLines(+getCurrentStep());
}

function getCurrentStep() {
  const input = document.getElementById("editStack").value.trim().replace(",", ".");
  const step = parseFloat(input);
  return isNaN(step) || step <= 0 ? TIME_STEP : step;
}

function shiftSelectedLines(delta) {
  const selected = document.querySelector('input[name="opcao-linha"]:checked');
  const value = selected ? selected.value : "current";

  const stateBefore = srtData.map(s => ({ ...s }));
  const prevSegment = currentSegment;

  if (value === "all") {
    isBatchEditing = true;
    srtData.forEach(seg => {
      currentSegment = seg;
      adjustTime("start", delta);
      adjustTime("end", delta);
    });
    isBatchEditing = false;
  } else if (value === "from-current" && currentSegment) {
    const startIdx = srtData.findIndex(s => s.id === currentSegment.id);
    if (startIdx >= 0) {
      isBatchEditing = true;
      for (let i = startIdx; i < srtData.length; i++) {
        currentSegment = srtData[i];
        adjustTime("start", delta);
        adjustTime("end", delta);
      }
      isBatchEditing = false;
    }
  } else if (value === "current" && currentSegment) {
    adjustTime("start", delta);
    adjustTime("end", delta);
  }

  const stateAfter = srtData.map(s => ({ ...s }));

  undoStack.push({
    type: "edit-multiple",
    delta,
    stateBefore,
    stateAfter
  });
  redoStack = [];

  currentSegment = prevSegment;
  renderSegments();
  if (currentSegment) updateEditorFields(currentSegment);
}

// ======================
// Inicializar
// ======================
function init() {
	showLoadArea();
	renderSegments();
}

init();

// ==================================
// üìÅ Fun√ß√µes de Carregamento
// ==================================
function editSrt() {
  console.log("");
  showVideoArea = true;
  showEditorArea = true;
  showSegmentsArea = true;
  showLoadArea = false;
  showSaveArea = false;
  showConfigArea = false;
  showPreviewMode = false;
  
  renderPage();
  showSection('editSrt');
}

function openContent() {
  console.log("=== IN√çCIO openContent() ===");
  
  // Captura os valores dos inputs
  const videoInput = document.getElementById("videoUrl").value.trim();
  const videoUpload = document.getElementById("videoUpload").files[0];
  console.log("Video URL input:", videoInput);
  console.log("Video Upload file:", videoUpload);

  const srtInput = document.getElementById("srtUrl").value.trim();
  const srtUpload = document.getElementById("srtUpload").files[0];
  console.log("SRT URL input:", srtInput);
  console.log("SRT Upload file:", srtUpload);

  // === IMPORTANTE: Muda para a se√ß√£o editSrt PRIMEIRO ===
  // Isso garante que o elemento videoPlayer seja criado
  console.log("--- Mudando para se√ß√£o 'editSrt' ANTES de carregar ---");
  editSrt();
  
  // Aguarda um momento para garantir que o DOM foi atualizado
  setTimeout(() => {
    console.log("--- Timeout executado, tentando carregar conte√∫do ---");
    
    // Verifica se o elemento de v√≠deo existe AGORA
    const videoElement = document.getElementById("videoPlayer");
    console.log("Elemento videoPlayer encontrado?", videoElement !== null);
    
    if (!videoElement) {
      console.error("‚ùå ERRO CR√çTICO: videoPlayer ainda n√£o existe!");
      alert("Erro: Elemento de v√≠deo n√£o encontrado. Tente novamente.");
      return;
    }

    // === CARREGAR O V√çDEO ===
    console.log("--- Tentando carregar v√≠deo ---");
    if (videoUpload) {
      // Se foi feito upload de arquivo
      console.log("Carregando v√≠deo via UPLOAD de arquivo:", videoUpload.name);
      const videoURL = URL.createObjectURL(videoUpload);
      console.log("URL do v√≠deo criada:", videoURL);
      videoElement.src = videoURL;
      console.log("V√≠deo carregado com sucesso via upload!");
    } else if (videoInput) {
      // Se foi colada uma URL
      console.log("Carregando v√≠deo via URL:", videoInput);
      videoElement.src = videoInput;
      console.log("V√≠deo carregado com sucesso via URL!");
    } else {
      console.warn("‚ö†Ô∏è AVISO: Nenhum v√≠deo foi fornecido (nem upload nem URL)");
    }

    // === CARREGAR A LEGENDA ===
    console.log("--- Tentando carregar legenda ---");
    if (srtUpload) {
      // Se foi feito upload de arquivo SRT
      console.log("Carregando SRT via UPLOAD de arquivo:", srtUpload.name);
      const reader = new FileReader();
      
      reader.onload = function (e) {
        console.log("FileReader onload disparado");
        console.log("Conte√∫do do SRT (primeiros 200 caracteres):", e.target.result.substring(0, 200));
        
        // Processa o conte√∫do do SRT
        parseSRT(e.target.result);
        console.log("parseSRT() executado. Total de segmentos:", srtData.length);
        
        // Atualizar o nome da legenda carregada
        subtitleName = srtUpload.name;
        const subtitleNameElement = document.getElementById("subtitleName");
        if (subtitleNameElement) {
          subtitleNameElement.textContent = subtitleName;
          console.log("Nome da legenda atualizado:", subtitleName);
        } else {
          console.warn("‚ö†Ô∏è Elemento subtitleName n√£o encontrado");
        }
      };
      
      reader.onerror = function(e) {
        console.error("‚ùå ERRO ao ler arquivo SRT:", e);
      };
      
      reader.readAsText(srtUpload);
      console.log("FileReader.readAsText() iniciado");
      
    } else if (srtInput) {
      // Se foi colada uma URL do SRT
      console.log("Carregando SRT via URL:", srtInput);
      
      fetch(srtInput)
        .then(res => {
          console.log("Fetch response status:", res.status);
          if (!res.ok) {
            throw new Error(`HTTP error! status: ${res.status}`);
          }
          return res.text();
        })
        .then(text => {
          console.log("SRT baixado via URL (primeiros 200 caracteres):", text.substring(0, 200));
          
          // Processa o conte√∫do do SRT
          parseSRT(text);
          console.log("parseSRT() executado. Total de segmentos:", srtData.length);

          // Atualizar o nome da legenda carregada (com URL)
          subtitleName = srtInput.split("/").pop();
          const subtitleNameElement = document.getElementById("subtitleName");
          if (subtitleNameElement) {
            subtitleNameElement.textContent = subtitleName;
            console.log("Nome da legenda atualizado:", subtitleName);
          } else {
            console.warn("‚ö†Ô∏è Elemento subtitleName n√£o encontrado");
          }
        })
        .catch(err => {
          console.error("‚ùå ERRO ao carregar SRT por URL:", err);
          alert("Erro ao carregar SRT por URL: " + err.message);
        });
        
    } else {
      console.warn("‚ö†Ô∏è AVISO: Nenhuma legenda foi fornecida (nem upload nem URL)");
    }
    
    console.log("=== FIM openContent() ===");
    
  }, 100); // Aguarda 100ms para o DOM atualizar
}

// Fun√ß√£o para interpretar o conte√∫do .srt para srtData
function parseSRT(content) {
  const lines = content.split(/\r?\n/);
  const segments = [];
  let i = 0;

  while (i < lines.length) {
    const id = parseInt(lines[i++]);
    const time = lines[i++];

    if (!time || !time.includes("-->")) continue;

    const [start, end] = time.split("-->").map(s => s.trim().replace(".", ","));
    let text = "";

    while (i < lines.length && lines[i].trim() !== "") {
      text += lines[i++] + "\n";
    }

    segments.push({
      id,
      start,
      end,
      text: text.trim()
    });

    while (i < lines.length && lines[i].trim() === "") i++;
  }

  srtData.length = 0;
  srtData.push(...segments);
  currentSegment = null;
  undoStack = [];
  redoStack = [];
  renderSegments();
  
}

// Exibir SRT
function showSRT() {
  const srt = generateSRT();
  const novaAba = window.open("", "_blank");

  if (novaAba) {
    novaAba.document.write(`<pre>${srt.replace(/</g, "&lt;").replace(/>/g, "&gt;")}</pre>`);
    novaAba.document.title = "SRT Gerado";
    novaAba.document.close();
  } else {
    alert("N√£o foi poss√≠vel abrir nova aba. Verifique se o bloqueador de pop-up est√° ativo.");
  }
}


function generateSRT() {
  return srtData.map(seg => {
    return `${seg.id}\n${seg.start} --> ${seg.end}\n${seg.text}`;
  }).join("\n\n");
}

function copyToClipboard() {
  const text = generateSRT();
  navigator.clipboard.writeText(text).then(() => {
    alert("Legendas copiadas para a √°rea de transfer√™ncia.");
  });
}

function downSrt() {
  // Verifique se o nome da legenda est√° configurado corretamente
  if (!subtitleName) {
    alert("Erro: Nome da legenda n√£o encontrado.");
    return;
  }

  const blob = new Blob([generateSRT()], { type: "text/plain;charset=utf-8" });
  const url = URL.createObjectURL(blob);
  const a = document.createElement("a");
  a.href = url;
  a.download = subtitleName;  // Usando o nome da legenda carregada
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
  URL.revokeObjectURL(url);
}

// Fun√ß√£o auxiliar para playLine()
// converter o tempo no formato 
// SRT (hh:mm:ss,SSS) para segundos
function parseTime(timeString) {
  const timeParts = timeString.split(/[:,]/);  // Separar por ":" e ","
  const hours = parseInt(timeParts[0], 10);
  const minutes = parseInt(timeParts[1], 10);
  const seconds = parseInt(timeParts[2], 10);
  const milliseconds = parseInt(timeParts[3], 10);

  // Converter tudo para segundos
  return hours * 3600 + minutes * 60 + seconds + milliseconds / 1000;
}

// Busca os tempos de in√≠cio e fim da legenda atual e 
// usa o v√≠deo (ou √°udio) para tocar o trecho
function playLine() {
  if (!currentSegment) {
    alert("Nenhum trecho selecionado.");
    return;
  }

  const videoElement = document.getElementById("videoPlayer");
  if (!videoElement || !videoElement.src) {
    alert("Carregue um v√≠deo primeiro!");
    return;
  }

  // **CR√çTICO: Limpa qualquer timeout anterior**
  if (stopTimeout) {
    clearTimeout(stopTimeout);
    stopTimeout = null;
  }

  // Pausa o v√≠deo se estiver tocando
  if (!videoElement.paused) {
    videoElement.pause();
  }

  const startTime = parseTime(currentSegment.start);
  const endTime = parseTime(currentSegment.end);

  // Aguarda um frame antes de iniciar (garante que pause foi processado)
  requestAnimationFrame(() => {
    videoElement.currentTime = startTime;
    videoElement.play();

    // Configura novo timeout para pausar no fim
    stopTimeout = setTimeout(() => {
      videoElement.pause();
      stopTimeout = null;
    }, (endTime - startTime) * 1000);
  });
}

// ‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò
//  - Bloco Fx | Thumbnail -
// ‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò
function handleCaptureClick() {
  const video = document.getElementById('videoPlayer'); // ID correto do v√≠deo
  
  if (!video) {
    console.error('Elemento de v√≠deo n√£o encontrado.');
    alert('V√≠deo n√£o encontrado. Certifique-se de ter carregado um v√≠deo.');
    return;
  }

  if (!video.src || video.readyState < 2) {
    alert('Aguarde o v√≠deo carregar completamente antes de capturar a thumbnail.');
    return;
  }

  const canvas = document.createElement('canvas');
  const context = canvas.getContext('2d');

  // Define as dimens√µes do canvas para corresponder √†s do v√≠deo
  canvas.width = video.videoWidth;
  canvas.height = video.videoHeight;

  // Desenha o frame atual do v√≠deo no canvas
  context.drawImage(video, 0, 0, canvas.width, canvas.height);

  // Converte o conte√∫do do canvas para Blob
  canvas.toBlob((blob) => {
    // Armazena o Blob globalmente
    if (blob) {
      capturedThumbnailBlob = blob;
      console.log('Thumbnail Blob capturado com sucesso!');

      // Converte o blob para uma URL de dados (imagem base64)
      const imageDataURL = URL.createObjectURL(blob);

      // Cria um novo elemento de imagem para a thumbnail
      const thumbnailImg = document.createElement('img');
      thumbnailImg.src = imageDataURL;
      thumbnailImg.alt = 'Thumbnail Capturada';
      thumbnailImg.style.maxWidth = '100%';
      thumbnailImg.style.height = 'auto';
      thumbnailImg.style.borderRadius = '8px';

      // Encontra o cont√™iner onde a thumbnail ser√° exibida
      const thumbContentDiv = document.getElementById('thumb-content');

      if (thumbContentDiv) {
        // Limpa qualquer conte√∫do anterior e adiciona a nova thumbnail
        thumbContentDiv.innerHTML = '';
        thumbContentDiv.appendChild(thumbnailImg);
      } else {
        console.error('Elemento com ID "thumb-content" n√£o encontrado.');
        alert('Erro: Container da thumbnail n√£o encontrado.');
      }
    } else {
      console.error('Falha ao gerar Blob da thumbnail.');
      alert('Erro ao capturar a thumbnail.');
    }
  }, 'image/jpeg', 0.9); // Usa o formato JPEG com qualidade de 90%
}

// ‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò
// --- Bloco Fx | Upload Backblaze --- 
// ‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò

/**
 * Obt√©m URL de upload do Backblaze via fun√ß√£o Appwrite
 */
async function getBackblazeUploadUrl() {
  console.log("--- Obtendo URL de upload do Backblaze ---");
  
  const { Functions } = Appwrite;
  const functions = new Functions(client);
  
  const result = await functions.createExecution(
    '68f7bd14002005b7bb6b',  // ID da sua fun√ß√£o
    JSON.stringify({}),
    false // s√≠ncrono
  );
  
  if (result.status !== 'completed') {
    throw new Error(`Falha na execu√ß√£o da fun√ß√£o: ${result.stderr}`);
  }
  
  const data = JSON.parse(result.responseBody);
  
  if (!data.uploadUrl || !data.authorizationToken) {
    throw new Error('Erro ao obter URL de upload');
  }
  
  console.log("‚úÖ URL de upload obtida com sucesso");
  return data;
}

/**
 * Faz upload de um arquivo para o Backblaze
 */
async function uploadFileToBackblaze(file, fileName, uploadData) {
  console.log(`--- Fazendo upload de: ${fileName} ---`);
  console.log(`Tamanho do arquivo: ${(file.size / 1024 / 1024).toFixed(2)} MB`);
  
  const headers = {
    'Authorization': uploadData.authorizationToken,
    'X-Bz-File-Name': encodeURIComponent(fileName),
    'Content-Type': file.type || 'b2/x-auto',
    'X-Bz-Content-Sha1': 'do_not_verify',
  };
  
  const uploadResponse = await fetch(uploadData.uploadUrl, {
    method: 'POST',
    headers: headers,
    body: file,
  });
  
  if (!uploadResponse.ok) {
    throw new Error(`Erro no upload de ${fileName}: ${uploadResponse.statusText}`);
  }
  
  const uploadResult = await uploadResponse.json();
  console.log(`‚úÖ Upload de ${fileName} conclu√≠do!`, uploadResult);
  
  return uploadResult;
}

/**
 * Converte v√≠deo do videoPlayer para Blob
 */
async function getVideoBlob() {
  console.log("--- Obtendo Blob do v√≠deo ---");
  
  const videoElement = document.getElementById('videoPlayer');
  
  if (!videoElement || !videoElement.src) {
    throw new Error('V√≠deo n√£o carregado');
  }
  
  // Se o v√≠deo foi carregado via upload (blob URL), precisa buscar novamente
  if (videoElement.src.startsWith('blob:')) {
    console.log("V√≠deo √© um blob local, buscando conte√∫do...");
    const response = await fetch(videoElement.src);
    const blob = await response.blob();
    console.log(`‚úÖ Blob do v√≠deo obtido: ${(blob.size / 1024 / 1024).toFixed(2)} MB`);
    return blob;
  }
  
  // Se o v√≠deo foi carregado via URL externa, precisa fazer fetch
  console.log("V√≠deo √© uma URL externa, fazendo fetch...");
  const response = await fetch(videoElement.src);
  const blob = await response.blob();
  console.log(`‚úÖ Blob do v√≠deo obtido: ${(blob.size / 1024 / 1024).toFixed(2)} MB`);
  return blob;
}

/**
 * Converte SRT data para Blob
 */
function getSrtBlob() {
  console.log("--- Criando Blob do SRT ---");
  const srtContent = generateSRT();
  const blob = new Blob([srtContent], { type: 'text/plain;charset=utf-8' });
  console.log(`‚úÖ Blob do SRT criado: ${blob.size} bytes`);
  return blob;
}

/**
 * Gera nome base a partir do nome do SRT (sem extens√£o)
 */
function getBaseName() {
  if (!subtitleName) {
    // Fallback: usa timestamp se n√£o houver nome
    return `lesson_${Date.now()}`;
  }
  // Remove a extens√£o .srt
  return subtitleName.replace(/\.srt$/i, '');
}

/**
 * Fun√ß√£o principal para postar a li√ß√£o
 */
async function postLesson() {
  console.log("=== IN√çCIO postLesson() ===");
  
  try {
    showLoading('Preparando upload...');
    
    // 1. Valida√ß√µes
    console.log("--- Validando dados ---");
    
    if (!srtData || srtData.length === 0) {
      throw new Error('Nenhuma legenda carregada. Carregue um arquivo SRT primeiro.');
    }
    
    if (!capturedThumbnailBlob) {
      throw new Error('Nenhuma thumbnail capturada. Clique no bot√£o üì∏ primeiro.');
    }
    
    const videoElement = document.getElementById('videoPlayer');
    if (!videoElement || !videoElement.src) {
      throw new Error('Nenhum v√≠deo carregado.');
    }
    
    console.log("‚úÖ Valida√ß√µes passaram");
    
    // 2. Gera nomes dos arquivos baseados no SRT
    const baseName = getBaseName();
    const videoFileName = `${baseName}.mp4`;
    const srtFileName = `${baseName}.srt`;
    const thumbFileName = `${baseName}.jpg`;
    
    console.log("--- Nomes dos arquivos ---");
    console.log("Base name:", baseName);
    console.log("Video:", videoFileName);
    console.log("SRT:", srtFileName);
    console.log("Thumb:", thumbFileName);
    
    // 3. Prepara os arquivos
    showLoading('Preparando arquivos...');
    const videoBlob = await getVideoBlob();
    const srtBlob = getSrtBlob();
    const thumbBlob = capturedThumbnailBlob;
    
    console.log("‚úÖ Todos os arquivos preparados");
    
    // 4. Faz upload dos 3 arquivos
    const uploadResults = {
      video: null,
      srt: null,
      thumb: null
    };
    
    // Upload do v√≠deo
    showLoading('Enviando v√≠deo... (1/3)');
    const videoUploadData = await getBackblazeUploadUrl();
    uploadResults.video = await uploadFileToBackblaze(videoBlob, videoFileName, videoUploadData);
    
    // Upload do SRT
    showLoading('Enviando legenda... (2/3)');
    const srtUploadData = await getBackblazeUploadUrl();
    uploadResults.srt = await uploadFileToBackblaze(srtBlob, srtFileName, srtUploadData);
    
    // Upload da thumbnail
    showLoading('Enviando thumbnail... (3/3)');
    const thumbUploadData = await getBackblazeUploadUrl();
    uploadResults.thumb = await uploadFileToBackblaze(thumbBlob, thumbFileName, thumbUploadData);
    
    console.log("=== UPLOADS CONCLU√çDOS ===");
    console.log("Video ID:", uploadResults.video.fileId);
    console.log("SRT ID:", uploadResults.srt.fileId);
    console.log("Thumb ID:", uploadResults.thumb.fileId);
    
    // 5. Exibe resultado no console (por enquanto)
    console.log("--- RESULTADO FINAL ---");
    console.log(JSON.stringify(uploadResults, null, 2));
    
    hideLoading();
    alert('‚úÖ Li√ß√£o postada com sucesso!\n\nVerifique o console (F12) para ver os IDs dos arquivos.');
    location.reload();
    
    // TODO: Salvar esses IDs no banco de dados
    // TODO: Exibir os arquivos na p√°gina
    
    return uploadResults;
    
  } catch (error) {
    console.error("‚ùå ERRO em postLesson():", error);
    hideLoading();
    alert('‚ùå Erro ao postar li√ß√£o: ' + error.message);
    throw error;
  } finally {
    console.log("=== FIM postLesson() ===");
  }
}

// ‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò
// --- Bloco Fx | Listar Thumbnails --- 
// ‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò

/**
 * Lista todos os arquivos do bucket via fun√ß√£o Appwrite
 */
async function listBackblazeFiles() {
  console.log("--- Listando arquivos do Backblaze ---");
  
  const { Functions } = Appwrite;
  const functions = new Functions(client);
  
  const result = await functions.createExecution(
    '68f7bd14002005b7bb6b',
    JSON.stringify({ action: 'list' }),
    false
  );
  
  if (result.status !== 'completed') {
    throw new Error(`Falha ao listar arquivos: ${result.stderr}`);
  }
  
  const data = JSON.parse(result.responseBody);
  console.log("‚úÖ Arquivos listados:", data.files?.length || 0);
  
  return data.files || [];
}

/**
 * Filtra apenas as thumbnails (arquivos .jpg/.jpeg/.png)
 */
function filterThumbnails(files) {
  const thumbs = files.filter(file => {
    const name = file.fileName.toLowerCase();
    return name.endsWith('.jpg') || name.endsWith('.jpeg') || name.endsWith('.png');
  });
  
  console.log(`‚úÖ Thumbnails encontradas: ${thumbs.length}`);
  return thumbs;
}

/**
 * Gera URL p√∫blica para arquivo do Backblaze usando o fileId
 */
function getBackblazePublicUrl(fileId) {
  return `https://f005.backblazeb2.com/b2api/v1/b2_download_file_by_id?fileId=${fileId}`;
}

/**
 * Renderiza as thumbnails nos elementos existentes (thumb-content e info-content)
 */
function renderThumbnails(thumbnails) {
  console.log("--- Renderizando thumbnails ---");
  console.log("Total de thumbnails:", thumbnails.length);
  
  const container = document.getElementById('home-post-container');
  
  if (!container) {
    console.error('Container user-post-container n√£o encontrado');
    return;
  }
  
  // Limpa o container
  container.innerHTML = '';
  
  if (thumbnails.length === 0) {
    container.innerHTML = '<p style="color: #888;">Nenhuma thumbnail encontrada.</p>';
    return;
  }
  
  // Cria um card para cada thumbnail usando os elementos existentes
  thumbnails.forEach((thumb, index) => {
    // Nome sem extens√£o
    const displayName = thumb.fileName.replace(/\.(jpg|jpeg|png)$/i, '');
    
    // Gera a URL p√∫blica usando o fileId
    const thumbnailUrl = getBackblazePublicUrl(thumb.fileId);
    
    // Log no console
    console.log(`[${index + 1}] Thumbnail:`, {
      fileName: thumb.fileName,
      displayName: displayName,
      fileId: thumb.fileId,
      url: thumbnailUrl,
      size: `${(thumb.contentLength / 1024).toFixed(2)} KB`
    });
    
    // Cria o wrapper do post
    const postWrapper = document.createElement('div');
    postWrapper.className = 'post-item';
    postWrapper.style.cssText = 'margin-bottom: 20px; cursor: pointer;';
    postWrapper.onclick = () => previewLesson(thumb);
    
    // Cria a thumb-section
    const thumbSection = document.createElement('div');
    thumbSection.className = 'thumb-section';
    thumbSection.innerHTML = `
      <img src="${thumbnailUrl}" alt="Preview da Thumbnail">
    `;
    
    // Cria a info-content
    const infoContent = document.createElement('div');
    infoContent.className = 'info-content';
    infoContent.innerHTML = `
      <div class="channel-pic">
        <img src="${thumbnailUrl}" alt="Canal" class="channel-pic">
      </div>
      
      <div class="video-text">
        <h3 class="video-title" onclick="previewLesson()" style="cursor: pointer;">${displayName}</h3>
        <div class="video-meta">
          <span class="channel-name">Meu Canal</span>
          <span class="performance">95%</span>
          <span class="video-edit" onclick="event.stopPropagation(); editLesson('${thumb.fileId}');" style="cursor: pointer; color: #6d28d9; font-weight: bold;">Editar</span>
        </div>
      </div>
    `;
    
    // Monta o post completo
    postWrapper.appendChild(thumbSection);
    postWrapper.appendChild(infoContent);
    
    // Adiciona ao container
    container.appendChild(postWrapper);
  });
  
  console.log(`‚úÖ ${thumbnails.length} thumbnails renderizadas`);
  console.log("--- Fim da renderiza√ß√£o ---");
}

/**
 * Fun√ß√£o principal para carregar e exibir thumbnails
 */
async function loadAndDisplayThumbnails() {
  console.log("=== IN√çCIO loadAndDisplayThumbnails() ===");
  
  try {
    showLoading('Carregando thumbnails...');
    
    // 1. Lista todos os arquivos
    const allFiles = await listBackblazeFiles();
    
    // 2. Filtra apenas as thumbnails
    const thumbnails = filterThumbnails(allFiles);
    
    // 3. Renderiza na p√°gina usando os elementos existentes
    renderThumbnails(thumbnails);
    
    hideLoading();
    
    return thumbnails;
    
  } catch (error) {
    console.error("‚ùå ERRO em loadAndDisplayThumbnails():", error);
    hideLoading();
    
    const container = document.getElementById('user-post-container');
    if (container) {
      container.innerHTML = `
        <p style="color: #ff6b6b; text-align: center; padding: 20px;">
          ‚ùå Erro ao carregar thumbnails: ${error.message}
        </p>
      `;
    }
    
    throw error;
  } finally {
    console.log("=== FIM loadAndDisplayThumbnails() ===");
  }
}

// ‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò
// --- Bloco Fx | Carregar Li√ß√£o do Servidor --- 
// ‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò

/**
 * Busca o arquivo de v√≠deo correspondente √† thumbnail
 */
function findVideoFile(thumbFileName, allFiles) {
  const baseName = thumbFileName.replace(/\.(jpg|jpeg|png)$/i, '');
  const videoFileName = `${baseName}.mp4`;
  
  console.log(`Procurando v√≠deo: ${videoFileName}`);
  
  const videoFile = allFiles.find(file => file.fileName === videoFileName);
  
  if (videoFile) {
    console.log("‚úÖ V√≠deo encontrado:", videoFile.fileName);
  } else {
    console.warn("‚ö†Ô∏è V√≠deo n√£o encontrado para:", thumbFileName);
  }
  
  return videoFile || null;
}

/**
 * Busca o arquivo SRT correspondente √† thumbnail
 */
function findSrtFile(thumbFileName, allFiles) {
  const baseName = thumbFileName.replace(/\.(jpg|jpeg|png)$/i, '');
  const srtFileName = `${baseName}.srt`;
  
  console.log(`Procurando SRT: ${srtFileName}`);
  
  const srtFile = allFiles.find(file => file.fileName === srtFileName);
  
  if (srtFile) {
    console.log("‚úÖ SRT encontrado:", srtFile.fileName);
  } else {
    console.warn("‚ö†Ô∏è SRT n√£o encontrado para:", thumbFileName);
  }
  
  return srtFile || null;
}

/**
 * Baixa e carrega o conte√∫do do SRT
 */
async function loadSrtContent(fileId) {
  console.log("--- Baixando SRT do servidor ---");
  
  const srtUrl = getBackblazePublicUrl(fileId);
  console.log("URL do SRT:", srtUrl);
  
  const response = await fetch(srtUrl);
  
  if (!response.ok) {
    throw new Error(`Erro ao baixar SRT: ${response.statusText}`);
  }
  
  const content = await response.text();
  console.log(`‚úÖ SRT baixado: ${content.length} caracteres`);
  
  return content;
}

/**
 * Carrega v√≠deo no elemento videoPlayer
 */
function loadVideoPlayer(fileId, fileName) {
  console.log("--- Carregando v√≠deo no player ---");
  
  const videoUrl = getBackblazePublicUrl(fileId);
  console.log("URL do v√≠deo:", videoUrl);
  
  const videoElement = document.getElementById('videoPlayer');
  
  if (!videoElement) {
    throw new Error('Elemento videoPlayer n√£o encontrado');
  }
  
  videoElement.src = videoUrl;
  console.log(`‚úÖ V√≠deo carregado: ${fileName}`);
}

/**
 * Carrega SRT no editor
 */
function loadSrtEditor(content, fileName) {
  console.log("--- Carregando SRT no editor ---");
  
  parseSRT(content);
  console.log(`‚úÖ SRT processado: ${srtData.length} segmentos`);
  
  subtitleName = fileName;
  const subtitleNameElement = document.getElementById("subtitleName");
  if (subtitleNameElement) {
    subtitleNameElement.textContent = fileName;
    console.log("‚úÖ Nome da legenda atualizado:", fileName);
  }
  
  renderSegments();
}

// ‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò
// --- Bloco Fx | Load Lesson From Server (com Cache) --- 
// ‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò

/**
 * Carrega li√ß√£o do servidor (ou cache)
 */
async function loadLessonFromServer(thumb) {
  console.log("=== IN√çCIO loadLessonFromServer() (com cache) ===");
  
  try {
    const fileId = thumb.fileId;
    const cached = loadLessonFromCache(fileId);
    
    if (cached) {
      console.log("üöÄ Carregando do CACHE (r√°pido)");
      showLoading('Carregando do cache...');
      
      await loadVideoFromCacheAsync(cached.videoBlob, cached.videoFileName);
      loadSrtEditor(cached.srtContent, cached.srtFileName);
      
      hideLoading();
      
      // Aguarda um frame para garantir renderiza√ß√£o
      await new Promise(resolve => requestAnimationFrame(resolve));
      
      if (srtData.length > 0) {
        openEditor(srtData[0].id);
      }
      
      return { /* ... */ };
    }
    
    // Carregamento do servidor
    showLoading('Carregando li√ß√£o...');
    const allFiles = await listBackblazeFiles();
    
    const videoFile = findVideoFile(thumb.fileName, allFiles);
    const srtFile = findSrtFile(thumb.fileName, allFiles);
    
    if (!videoFile || !srtFile) {
      throw new Error('Arquivos n√£o encontrados');
    }
    
    showLoading('Carregando v√≠deo...');
    await loadVideoPlayerAsync(videoFile.fileId, videoFile.fileName);
    
    showLoading('Carregando legenda...');
    const srtContent = await loadSrtContent(srtFile.fileId);
    loadSrtEditor(srtContent, srtFile.fileName);
    
    showLoading('Salvando no cache...');
    await saveLessonToCache(fileId, videoFile, srtFile, thumb);
    
    hideLoading();
    
    // Aguarda um frame para garantir renderiza√ß√£o
    await new Promise(resolve => requestAnimationFrame(resolve));
    
    if (srtData.length > 0) {
      openEditor(srtData[0].id);
    }
    
    return { /* ... */ };
    
  } catch (error) {
    console.error("‚ùå ERRO:", error);
    hideLoading();
    alert('‚ùå Erro: ' + error.message);
    throw error;
  }
}

// Nova fun√ß√£o ass√≠ncrona para carregar v√≠deo
function loadVideoPlayerAsync(fileId, fileName) {
  return new Promise((resolve, reject) => {
    console.log("--- Carregando v√≠deo no player ---");
    
    const videoUrl = getBackblazePublicUrl(fileId);
    const videoElement = document.getElementById('videoPlayer');
    
    if (!videoElement) {
      reject(new Error('videoPlayer n√£o encontrado'));
      return;
    }
    
    // Aguarda o v√≠deo carregar metadados
    videoElement.onloadedmetadata = () => {
      console.log(`‚úÖ V√≠deo carregado: ${fileName}`);
      resolve();
    };
    
    videoElement.onerror = () => {
      reject(new Error('Erro ao carregar v√≠deo'));
    };
    
    videoElement.src = videoUrl;
  });
}

// Nova fun√ß√£o ass√≠ncrona para carregar v√≠deo do cache
function loadVideoFromCacheAsync(videoBlob, fileName) {
  return new Promise((resolve, reject) => {
    const videoElement = document.getElementById('videoPlayer');
    
    if (!videoElement) {
      reject(new Error('videoPlayer n√£o encontrado'));
      return;
    }
    
    const blobUrl = URL.createObjectURL(videoBlob);
    
    videoElement.onloadedmetadata = () => {
      console.log(`‚úÖ V√≠deo do cache carregado: ${fileName}`);
      resolve();
    };
    
    videoElement.onerror = () => {
      reject(new Error('Erro ao carregar v√≠deo do cache'));
    };
    
    videoElement.src = blobUrl;
  });
}

// ‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò
// --- Bloco Fx | PreviewMode --- 
// ‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò
/**
 * Preview de li√ß√£o (carrega do servidor)
 */
async function previewLesson(thumb) {
  // Define TODAS as flags de visibilidade
  showVideoArea = true;
  showEditorArea = false;
  showSegmentsArea = true;
  showSaveArea = false;
  showLoadArea = false;
  showConfigArea = false;
  
  showSection('editSrt'); 
  
  showPreviewMode = true;
  
  renderPage();
  
  await loadLessonFromServer(thumb);
    
}

/**
 * Fun√ß√£o placeholder para editar (voc√™ pode implementar depois)
 */
function editLesson(fileId) {
  console.log("Editar li√ß√£o:", fileId);
  // TODO: Implementar edi√ß√£o
}


// ‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò
// --- Bloco Fx | Play --- 
// ‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò
/**
 * Aguarda a renderiza√ß√£o completa e toca o √°udio
 */
async function waitForRenderAndPlay() {
  console.log("--- Aguardando renderiza√ß√£o completa ---");
  
  // Aguarda um frame para garantir que o DOM foi atualizado
  await new Promise(resolve => requestAnimationFrame(resolve));
  
  // Verifica se o v√≠deo est√° pronto
  const videoElement = document.getElementById("videoPlayer");
  
  if (!videoElement) {
    console.error("‚ùå videoPlayer n√£o encontrado");
    return;
  }
  
  // Se o v√≠deo n√£o estiver pronto, aguarda
  if (videoElement.readyState < 2) {
    console.log("‚è≥ Aguardando v√≠deo carregar...");
    await new Promise(resolve => {
      videoElement.addEventListener('loadeddata', resolve, { once: true });
    });
  }
  
  console.log("‚úÖ Renderiza√ß√£o completa, tocando √°udio...");
  
  // Agora sim, toca o trecho
  playLine();
}

/**
 * Embaralha um array (Fisher-Yates shuffle)
 */
function shuffleArray(array) {
  const shuffled = [...array];
  for (let i = shuffled.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
  }
  return shuffled;
}

/**
 * Injeta o primeiro trecho da SRT com palavras embaralhadas (ATUALIZADO)
 */
async function injectFirstSegmentShuffled() {
  console.log("--- Injetando primeiro trecho embaralhado ---");
  
  // Reseta o √≠ndice e array de palavras
  currentSegmentIndex = 0;
  selectedWords = [];
  
  if (!srtData || srtData.length === 0) {
    console.warn("‚ö†Ô∏è Nenhuma legenda carregada");
    return;
  }
  
  // Carrega o primeiro segmento (que j√° vai chamar playLine)
  await loadNextSegment();
}

/**
 * Move palavra para o container de frase
 */
function moveWordToPhrase(wordButton, word) {
  console.log("Tentando mover palavra:", word);
  
  // Verifica se √© a pr√≥xima palavra correta
  if (!isNextWord(word)) {
    console.log("‚ùå Palavra incorreta! N√£o √© a pr√≥xima da sequ√™ncia.");
    
    // Feedback visual de erro
    wordButton.style.background = 'linear-gradient(to bottom, #ff5e91, #E91E63)';
    setTimeout(() => {
      wordButton.style.background = 'linear-gradient(to bottom, #6d28d9, #5b21b6)';
    }, 300);
    
    return;
  }
  
  console.log("‚úÖ Palavra correta! Movendo...");
  
  const fraseContainer = document.getElementById('frase');
  
  if (!fraseContainer) {
    console.error("‚ùå Elemento 'frase' n√£o encontrado");
    return;
  }
  
  selectedWords.push(word);
  wordButton.remove();
  
  const phraseButton = document.createElement('button');
  phraseButton.className = 'phrase-word-button';
  phraseButton.textContent = word;
  phraseButton.style.cssText = `
    padding: 12px 20px;
    margin: 8px;
    background: linear-gradient(to bottom, #4caf50, #45a049);
    color: #fff;
    border: none;
    border-radius: 8px;
    font-size: 16px;
    cursor: pointer;
    transition: all 0.3s ease;
    box-shadow: 0 2px 8px rgba(76, 175, 80, 0.3);
  `;
  
  fraseContainer.appendChild(phraseButton);
  
  console.log("Frase atual:", selectedWords.join(' '));
  
  // Verifica se a frase est√° completa
  checkIfPhraseComplete();
}

/**
 * Verifica se a palavra clicada √© a pr√≥xima correta da frase (ATUALIZADO PARA PALAVRAS DUPLICADAS)
 */
function isNextWord(word) {
  // Pega o segmento atual
  const currentSegment = srtData[currentSegmentIndex];
  
  const correctWords = currentSegment.text
    .split(/\s+/)
    .filter(w => w.trim().length > 0);
  
  const nextIndex = selectedWords.length;
  
  if (nextIndex >= correctWords.length) {
    return false;
  }
  
  // Em vez de comparar posi√ß√£o exata, verifica se a palavra existe
  // nas palavras corretas e ainda n√£o foi totalmente usada
  const wordCountInCorrect = correctWords.filter(w => w === word).length;
  const wordCountInSelected = selectedWords.filter(w => w === word).length;
  
  // A palavra s√≥ √© v√°lida se:
  // 1. Existe na frase original
  // 2. Ainda n√£o foi usada todas as vezes que aparece
  return wordCountInCorrect > wordCountInSelected;
}

/**
 * Verifica se a frase est√° completa e mostra a pr√≥xima (ATUALIZADA PARA ASYNC)
 */
function checkIfPhraseComplete() {
  const currentSegment = srtData[currentSegmentIndex];
  
  const correctWords = currentSegment.text
    .split(/\s+/)
    .filter(w => w.trim().length > 0);
  
  if (selectedWords.length === correctWords.length) {
    console.log("üéâ Frase completa!");
    
    // Para o timer de performance
    stopSegmentTimer();
    
    // √öltima atualiza√ß√£o da performance (mostra resultado final)
    updatePerformanceDisplay();
    
    setTimeout(async () => {
      currentSegmentIndex++;
      
      if (currentSegmentIndex < srtData.length) {
        console.log(`Carregando segmento ${currentSegmentIndex + 1}...`);
        await loadNextSegment();
      } else {
        console.log("üèÜ Todas as frases completadas!");
        showCompletionMessage();
      }
    }, 1000);
  }
}

/**
 * Carrega o pr√≥ximo segmento (ATUALIZADO COM VERIFICA√á√ÉO ROBUSTA)
 */
async function loadNextSegment() {
  // Limpa o array de palavras selecionadas
  selectedWords = [];
  
  // Pega o pr√≥ximo segmento
  const nextSegment = srtData[currentSegmentIndex];
  console.log("Pr√≥ximo trecho:", nextSegment);
  
  // Define como segmento atual (para playLine funcionar)
  currentSegment = nextSegment;
  
  // Encontra os containers
  const palavrasContainer = document.getElementById('palavras');
  const fraseContainer = document.getElementById('frase');
  
  if (!palavrasContainer || !fraseContainer) {
    console.error("‚ùå Containers n√£o encontrados");
    return;
  }
  
  // Limpa os containers
  palavrasContainer.innerHTML = '';
  fraseContainer.innerHTML = '';
  
  // Separa o texto em palavras
  const words = nextSegment.text
    .split(/\s+/)
    .filter(word => word.trim().length > 0);
  
  // Embaralha as palavras
  const shuffledWords = shuffleArray(words);
  console.log("Palavras embaralhadas:", shuffledWords);
  
  // Cria bot√µes para cada palavra
  shuffledWords.forEach((word) => {
    const wordButton = document.createElement('button');
    wordButton.className = 'word-button';
    wordButton.textContent = word;
    wordButton.style.cssText = `
      padding: 12px 20px;
      margin: 8px;
      background: linear-gradient(to bottom, #6d28d9, #5b21b6);
      color: #fff;
      border: none;
      border-radius: 8px;
      font-size: 16px;
      cursor: pointer;
      transition: all 0.3s ease;
      box-shadow: 0 2px 8px rgba(109, 40, 217, 0.3);
    `;
    
    // Efeitos hover
    wordButton.onmouseenter = () => {
      wordButton.style.transform = 'translateY(-2px)';
      wordButton.style.boxShadow = '0 4px 12px rgba(109, 40, 217, 0.5)';
    };
    
    wordButton.onmouseleave = () => {
      wordButton.style.transform = 'translateY(0)';
      wordButton.style.boxShadow = '0 2px 8px rgba(109, 40, 217, 0.3)';
    };
    
    // A√ß√£o ao clicar
    wordButton.onclick = () => {
      moveWordToPhrase(wordButton, word);
    };
    
    palavrasContainer.appendChild(wordButton);
  });
  
  // Atualiza o progresso
  updateProgress();
  
  console.log(`‚úÖ Segmento ${currentSegmentIndex + 1} carregado`);
  
  // üéµ AGUARDA RENDERIZA√á√ÉO ANTES DE TOCAR (ROBUSTA)
  await waitForRenderAndPlay();
  
  // ‚è±Ô∏è INICIA O CRON√îMETRO DE PERFORMANCE
  startSegmentTimer();
}

/**
 * Atualiza o display de progresso
 */
function updateProgress() {
  const progressElement = document.getElementById('progresso');
  
  if (progressElement) {
    progressElement.textContent = `Progresso: ${currentSegmentIndex + 1} de ${srtData.length}`;
  }
}

/**
 * Mostra mensagem de conclus√£o
 */
function showCompletionMessage() {
  const fraseContainer = document.getElementById('frase');
  const palavrasContainer = document.getElementById('palavras');
  
  if (fraseContainer) {
    fraseContainer.innerHTML = '<h2 style="color: #4caf50;">üèÜ Parab√©ns! Voc√™ completou todas as frases!</h2>';
  }
  
  if (palavrasContainer) {
    palavrasContainer.innerHTML = '';
  }
}

/**
 * Inicia o modo solo
 */
function startSoloMode() {
  console.log("=== IN√çCIO startPlayMode() ===");
  
  // Injeta o primeiro trecho se estivermos no modo play
  injectFirstSegmentShuffled();
  
  showSection('play');  // ‚úÖ Muda para a se√ß√£o play
}

</script>
</body>
</html>
