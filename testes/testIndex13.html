<!-- solo section -->
<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Dark Page</title>

<script src="https://cdn.jsdelivr.net/npm/appwrite@18.2.0"></script>

<style>
  body {
    margin: 0;
    font-family: Arial, sans-serif;
    background: #000;
    color: #fff;
  }
  
.hidden {
    display: none !important;
}

  /*=================*/
 /* Loading Overlay */
/*=================*/
.loading-overlay {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0, 0, 0, 0.9);
    display: none;
    align-items: center;
    justify-content: center;
    z-index: 9999;
    flex-direction: column;
    gap: 20px;
}

.loading-overlay.active {
    display: flex;
}

.loading-spinner {
    width: 50px;
    height: 50px;
    border: 4px solid #333;
    border-top: 4px solid #6d28d9;
    border-radius: 50%;
    animation: spin 1s linear infinite;
}

.loading-text {
    color: #fff;
    font-size: 16px;
    text-align: center;
}

@keyframes spin {
    0% { transform: rotate(0deg); }
    100% { transform: rotate(360deg); }
}

h2 {
  margin-top: 30px;
}

input[type="text"] {
  width: 100%;
  height: 50%;
  padding: 8px;
  margin-top: 5px;
  margin-bottom: 20px;
  box-sizing: border-box;
}

  header, footer {
    position: fixed;
    left: 0; right: 0;
    display: flex;
    align-items: center;
    justify-content: space-between;
    background: #000;
    padding: 0 16px;
  }

  header { top: 0; height: 56px; border-bottom: 1px solid #222; }
  footer { bottom: 0; height: 70px; border-top: 1px solid #222; justify-content: space-around; font-size: 12px; color: #aaa; }

  .logo-area { display: flex; align-items: center; gap: 8px;}
  
  .logo-area img { background: #fff; color: #000;  border-radius: 15%;}


  .icons-right, footer a {
    display: flex;
    align-items: center;
    gap: 20px;
    color: #fff;
    text-decoration: none;
    cursor: pointer;
  }

  .icon, footer svg {
    width: 24px; height: 24px; fill: currentColor;
  }

  main { padding: 70px 16px 90px; text-align: center; }

.video-container {
  widht: 100vw;
  max-width: 600px;
  height: 30vh
  background: #1e1e1e;
  overflow: hidden;
}

.video-title {
  font-size: 14px;
  font-weight: 600;
  color: #fff;
  margin: 2px 0 8px 0;
  text-align: left;
}

.channel-info {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin: 0 10px 8px;
  font-size: 12px;;
}

.channel-pic {
  width: 40px;
  height: 40px;
  border-radius: 50%;
  object-fit: cover;
}

.video-text {
  flex: 1;
  display: flex;
  flex-direction: column;
  gap: 4px;
}

.video-meta {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin: 0 10px 8px;
  font-size: 12px;
}

.video-thumb {
  position: relative;
  widht: 100vw;
  max-width: 600px;
  height: 30vh
}

.video-thumb img {
  width: 100%;
  display: block;
}

.video-time {
  position: absolute;
  bottom: 8px;
  right: 8px;
  background: rgba(0,0,0,0.7);
  padding: 2px 6px;
  font-size: 12px;
  border-radius: 4px;
}

.performance {
  color: #4caf50;
  font-weight: bold;
}

footer a {
  /* 1. Transforma o link em um cont√™iner flex√≠vel */
  display: flex;
  
  /* 2. Empilha os itens verticalmente (√≠cone em cima, texto embaixo) */
  flex-direction: column; 
  
  /* 3. Centraliza os itens horizontalmente */
  align-items: center; 
  
  /* 4. Esta √© a propriedade principal para controlar a dist√¢ncia! */
  gap: 4px; /* ‚ú® Altere este valor para aumentar ou diminuir o espa√ßo */
}

/* Apenas para estiliza√ß√£o do exemplo */
footer {
  display: flex;
  justify-content: space-around;
}

footer a {
  text-decoration: none;
  font-family: sans-serif;
  font-size: 12px;
}

footer svg {
  width: 20px;
  height: 20px;
}

.avatar {
    width: 20px;
    height: 20px;
    border-radius: 50%;
    background-color: #6d28d9;
    color: white;
    display: grid;
    place-content: center;
    font-weight: bold;
}

.playlist-item {
  display: flex;
  align-items: center;
  margin-bottom: 10px;
}

.playlist-item input {
  margin-right: 10px;
}

section { display: none; }           /* todas escondidas */
section.active { display: block; }   /* vis√≠vel */

.video-section {
    background: ;
    padding: 20px;
    border-radius: 8px;
}

video {
    width: 100%;
    border-radius: 4px;
}

.video-thumb {
    position: relative;
    width: 100%;       /* Certifique-se que a div tenha 100% de largura */
    height: 100%;      /* Ou defina uma altura espec√≠fica caso necess√°rio */
    overflow: hidden;  /* Garante que a imagem n√£o saia da div */
}

.video-thumb-img {
    width: auto;       /* A largura se ajusta proporcionalmente */
    height: 100%;      /* Limita a altura a 100% da altura da div */
    object-fit: cover; /* Garante que a imagem ocupe toda a √°rea sem distorcer, mantendo a propor√ß√£o */
}

</style>
</head>
<body>

  <!-- Loading Overlay -->
  <div id="loadingOverlay" class="loading-overlay">
      <div class="loading-spinner"></div>
      <div class="loading-text" id="loadingText">Carregando...</div>
  </div>
  
  <header>
  	<span id="btn-goBack" onclick="goBack()" class="hidden">‚Üê Voltar</span>
    <div class="logo-area">
        <img src="https://files.catbox.moe/6nkxcx.svg" alt="√çcone SVG" width="30" height="30" />
      <div>PhraseCraft</div>
    </div>
    <div class="icons-right">
      <!-- Create -->
      <a href="#" id="icon-create" onclick="showSection('create')" hidden>
        <svg class="icon" viewBox="0 0 24 24">
        <path fill-rule="evenodd" d="M17 10.5V7a1 1 0 0 0-1-1H4a1 1 0 0 0-1 1v10a1 1 0 0 0 1 1h12a1 1 0 0 0 1-1v-3.5l4 4V6.5l-4 4zM11 11V9H9v2H7v2h2v2h2v-2h2v-2h-2z"/>
        </svg>
      </a>
      <!-- Search -->
      <a href="#" onclick="showSection('search')">
        <svg class="icon" viewBox="0 0 24 24"><path d="M21 20l-5.8-5.8A7 7 0 1 0 4 11a7 7 0 0 0 11.2 5.6L21 20zM6 11a5 5 0 1 1 10 0a5 5 0 0 1-10 0z"/></svg>
      </a>
      <a href="#" onclick="showSection('notifications')">
      <svg class="icon" viewBox="0 0 24 24"><path d="M12 22a2.5 2.5 0 0 0 2.5-2.5h-5A2.5 2.5 0 0 0 12 22zm6-6V11c0-3.3-2.2-6-5-6V4a1 1 0 1 0-2 0v1c-2.8 0-5 2.7-5 6v5l-1.9 1.9A1 1 0 0 0 6 20h12a1 1 0 0 0 .9-1.6L18 16z"/></svg>
      </a>
    </div>
  </header>

  <main>
  	<!-- Player √önico de v√≠deo real em um lugar "neutro" -->
    <div id="videoStorage" class="hidden">
      <video id="mainVideoPlayer" controls crossorigin="anonymous"></video>
    </div>
    
    <section id="home" class="active">
        <h2>Home</h2>
        <p>Welcome to the home section.</p>
        <div id="home-post-container">
            <!-- Os cards de v√≠deo ser√£o inseridos aqui -->
        </div>
    </section>

    <section id="search">
      <h2>Search</h2>
      <p>Use this section to search content.</p>
    </section>

    <section id="notifications">
      <h2>Notifications</h2>
      <p>Here are your notifications.</p>
    </section>

    <section id="you">
      <h2>You</h2>
      <p>This section is about your profile.</p>
                      
      <div class="botoes-container">
          <a href="#" onclick="showProfile()">Meu Perfil</a>
          <a href="#" id="btn-myPosts" onclick="showSection('myPosts')">Minhas Postagens</a>
      </div>
    </section>

    <section id="subscriptions">
      <h2>Subscriptions</h2>
      <p>See all your subscriptions here.</p>
    </section>

    <section id="create">
        <h2>Create</h2>
        <p>Use this section to create new content.</p>
        <div class="load-group">
            <label for="videoUpload" class="upload-btn">Upload V√≠deo</label>
            <input type="file" id="videoUpload" accept="video/*">
        </div>
        <div class="load-group">
            <label for="srtUpload" class="upload-btn">Upload SRT</label>
            <input type="file" id="srtUpload" accept=".srt">
        </div>

        <div class="botoes-container">
            <a href="#" onclick="openContent()">Carregar</a>
        </div>
    </section>
    
    <!-- Subsections -->
    <section id="postLesson">
      <h2>Post</h2>
      <p>Use this section to post.</p>
                      
      <div class="botoes-container">
          <button href="#" onclick="postLesson()">Postar Li√ß√£o</button>
      </div>
                      
      <div class="botoes-container">
          <button onclick="showSection('editSrt')">Editar Srt</button>
      </div>

      <div id="postPlayerContainer" class="video-section"></div>

      <button id="captureBtn" class="thumb-gen-button">üì∏ Capturar Thumbnail</button>

      <div id="previewContainer" class="thumb-gen-preview">
          <span>A pr√©-visualiza√ß√£o da sua thumbnail aparecer√° aqui.</span>
      </div>
      
      <!-- T√≠tulo -->
      <h2>Nome</h2>
      <!-- Input de texto -->
      <input type="text" placeholder="Digite um nome..." name="nome" />
      
      <!-- T√≠tulo -->
      <h2>Descri√ß√£o</h2>
      <!-- Input de texto -->
      <input type="text" placeholder="Digite uma descri√ß√£o..." name="description" />

      <!-- T√≠tulo -->
      <h2>Adicionar √† Playlist</h2>
      <!-- Lista de checkboxes com nomes de playlists -->
      <div class="playlist-item">
        <input type="checkbox" id="playlist1" name="playlist" value="Playlist 1" />
        <label for="playlist1">Playlist 1</label>
      </div>

      <div class="playlist-item">
        <input type="checkbox" id="playlist2" name="playlist" value="Playlist 2" />
        <label for="playlist2">Playlist 2</label>
      </div>

      <div class="playlist-item">
        <input type="checkbox" id="playlist3" name="playlist" value="Playlist 3" />
        <label for="playlist3">Playlist 3</label>
      </div>
      
    </section>
    
    <section id="editSrt">
      <h2>Editar SRT</h2>
      <div class="editor" id="editor">

        <!-- Div para exibir o nome do arquivo da legenda -->
        <p id="subtitleName"></p>

        <div id="editPlayerContainer" class="video-section"></div>
        
        <label>In√≠cio</label>
        <div class="time-controls">
          <input id="editStart">
          <button onclick="adjustTime('start',  -TIME_STEP)">‚àí</button>
          <button onclick="adjustTime('start', +TIME_STEP)">+</button>

          <button onclick="undo()">‚Ü©</button>
          <button onclick="redo()">‚Ü™</button>
        </div>

        <label>Fim</label>
        <div class="time-controls">
          <input id="editEnd">
          <button onclick="adjustTime('end', -TIME_STEP)">‚àí</button>
          <button onclick="adjustTime('end', +TIME_STEP)">+</button>

          <button onclick="addSegment()">‚ò∞ ‚ûïÔ∏è</button>
          <button onclick="removeSegment()">‚ò∞ ‚ûñ</button>
        </div>

        <label>Texto</label>
        <textarea id="editText" rows="3"></textarea>

        <button id="btn-load" onclick="showLoadArea()">üìÇ</button>
        <button onclick="prevLine()">‚óÄ‚óÄ</button>
        <button onclick="playLine()">‚ñ∂</button>
        <button onclick="nextLine()">‚ñ∂‚ñ∂</button>
        <button id="btn-save" onclick="showSaveArea()">üíæ</button>

        <p id="btn-config" onclick="showConfigEdit()">‚öô Editar em Lote</p>

        <div id="config-area" hidden>
            <span id="btn-close" onclick="closeConfigEdit()">&times;</span>
            <div class="time-controls">
              <input id="editStack" placeholder="0.05">
              <button onclick="showEarlier()">Adiantar</button>
              <button onclick="showLater()">Atrasar</button>
            </div>

            <form id="linhaForm">
              <label class="radio-option">
                <input type="radio" name="opcao-linha" value="all" checked>
                Todas as linhas
              </label>
              <label class="radio-option">
                <input type="radio" name="opcao-linha" value="current">
                Apenas linha atual
              </label>

            <label class="radio-option">
              <input type="radio" name="opcao-linha" value="from-current">
              Linha selecionada e pr√≥ximas linhas
            </label>
            </form>
            <hr>
        </div>
    </div>

    <div class="segmentsArea" id="segments-area">
        <div id="segments"></div>
    </div>

    </section>
    
    <section id="profile">
      <h2>My Account</h2>
      <p>Use this section to see and edit your profile.</p>
      <div class="header-content"  id="header-content">
      
        <div class="user-buttons">
            <div id="user-email-display" style="font-size: 0.9em; color: rgba(255, 255, 255, 0.7);"></div>

			<div class="botoes-container">
				<button id="btnLogin" class="btnLogin" onclick="showSection('login-screen')">Entrar</button><hr>
            	<button id="logout-button" class="" onclick="handleLogout()" hidden>Sair</button>
            </div>
            
        </div>
      </div>
    </section>
    
    <section id="myPosts">
        <h2>My Lessons Posts</h2>
        <p>Use this section to see your lessons posted.</p>
        <div id="user-post-container">
            <!-- Os cards de v√≠deo do usu√°rio ser√£o inseridos aqui -->
        </div>
    </section>

    <section id="login-screen" class="login-screen-container">
        <div class="login-card">
            <h2>Entrar</h2>
            <form id="login-form">
                <input type="email" id="email-login" placeholder="E-mail" required>
                <input type="password" id="password-login" placeholder="Senha" required>
                <p id="login-message"></p>
                <button type="submit" class="login-button">Entrar</button>
            </form>
        </div>
    </section>

    <section id="solo" class="content-row">
            <div class="video-container">
                <video id="custom-video" class="hide-controls" preload="auto" crossorigin="anonymous">
                </video>
        
                <div id="subtitle-content" class="hidden"> 
                	<!- As legendas aparecem aqui: -->
                </div>
                
            </div>

            <div id="buttons">
                <button id="repetir" class="control-button" style="background: linear-gradient(to bottom, #b34dd6 0%, #9C27B0 50%, #7c1f8e 100%);">Tocar Trecho</button>
                <button id="lerFrase" class="control-button" style="background: linear-gradient(to bottom, #78c0ff 0%, #5babf0 50%, #4d98e5 100%);">Tocar Lento</button>
                <button id="traduzir-btn" class="control-button" style="background: linear-gradient(to bottom, #ffc078 0%, #ffa94d 50%, #e59442 100%);">Traduzir</button>
                <button id="desistir" class="control-button" style="background: linear-gradient(to bottom, #ff5e91 0%, #E91E63 50%, #c41858 100%);">Passar</button>
                
             </div>
            
        </div>

        <div class="phrase-container" id="frase">
        </div>

        <div class="word-button-wrapper">
        
            <div class="word-container" id="palavras"></div>
            
        </div>
        
        <div id="progresso" style="margin-top: 10px; font-size: 0.9em;">Progresso: 0 de 0</div>
    </section>

    <section id="challenge" class="">
      
      <!-- Criadas -->
      <h2>Partidas Criadas</h2>
      <p>Use this section to see all matches waiting a second player.</p>
      
    </section>

  </main>

  <footer id="main-footer">
    <a href="#" onclick="showSection('home')" class="active">
      <svg viewBox="0 0 24 24"><path d="M12 3.3l8 6V20a1 1 0 0 1-1 1h-5v-6H10v6H5a1 1 0 0 1-1-1V9.3l8-6z"/></svg>
      <span>Home</span>
    </a>
    <a href="#" onclick="showSection('subscriptions')">
      <svg viewBox="0 0 24 24"><path d="M17 10.5V7a1 1 0 0 0-1-1H4a1 1 0 0 0-1 1v10a1 1 0 0 0 1 1h12a1 1 0 0 0 1-1v-3.5l4 4V6.5l-4 4z"/></svg>
      <span>Subscriptions</span>
    </a>
    <a href="#" onclick="showSection('you')">
        <img src="https://files.catbox.moe/p2znlg.svg" alt="√çcone SVG" width="21" height="21" /><span>You</span></a>
    <a href="#" onclick="showSection('challenge')">
        <img src="https://files.catbox.moe/tdzklr.svg" alt="√çcone SVG" width="25" height="25" /><span>Desafios</span></a>
  </footer>

  <footer id="preview-footer" style="display: none;">
    <a href="#" onclick="showSection('solo')">
        <img src="https://files.catbox.moe/p2znlg.svg" alt="√çcone SVG" width="21" height="21" /><span>Solo</span></a>
    <a href="#" onclick="showSection('')">
        <img src="https://files.catbox.moe/tdzklr.svg" alt="√çcone SVG" width="25" height="25" /><span>Desafiar</span></a>
  </footer>

  <script>
let sectionHistory = ['home'];

// üõë NOVAS VARI√ÅVEIS GLOBAIS NECESS√ÅRIAS PARA O EDITOR SRT
let srtData = []; 
let currentSegment = null;
let undoStack = [];
let redoStack = [];
const TIME_STEP = 0.05; // 50 milissegundos
let stopTimeout = null;
let isBatchEditing = false;
let subtitleName = "legenda.srt"; // Nome padr√£o para download

let isEditMode = false;
let isPreviewMode = false;
// FIM DAS NOVAS VARI√ÅVEIS GLOBAIS

function showSection(targetId) {
    const sections = ['home', 'search', 'notifications', 'you', 'subscriptions', 'create', 'postLesson', 'editSrt', 'myPosts', 'profile', 'login-screen', 'challenge', 'solo'];
    
    // Detecta se estava no editSrt ANTES de trocar de se√ß√£o
    const wasInEditSrt = document.getElementById('editSrt')?.classList.contains('active');
    
    // ‚úÖ CORRIGIDO: S√≥ desativa preview se N√ÉO for uma navega√ß√£o tempor√°ria
    // Mant√©m o preview se est√° saindo temporariamente (ex: para outras se√ß√µes)
    if (wasInEditSrt && targetId !== 'editSrt' && window.isPreviewMode) {
        // N√ÉO desativa mais automaticamente - deixa o goBack() gerenciar
        console.log('[showSection] Saindo de editSrt em modo preview (estado preservado)');
    }
    
    // ‚≠ê PEGA O PLAYER DE V√çDEO E SEU "ESCONDERIJO" ORIGINAL
    const videoPlayer = document.getElementById('mainVideoPlayer');
    const videoStorage = document.getElementById('videoStorage');
    
    // ‚≠ê NOVA L√ìGICA: Aguarda o v√≠deo carregar antes de mover
    const moveVideoToSection = () => {
        if (targetId === 'postLesson') {
            document.getElementById('postPlayerContainer').appendChild(videoPlayer);
        } else if (targetId === 'editSrt') {
            document.getElementById('editPlayerContainer').appendChild(videoPlayer);
        } else {
            videoStorage.appendChild(videoPlayer);
        }
        hideLoading(); // Esconde o loading quando o v√≠deo estiver pronto
    };
    
    // Se o v√≠deo tem src e est√° indo para uma se√ß√£o de v√≠deo, aguarda carregar
    if (videoPlayer.src && (targetId === 'postLesson' || targetId === 'editSrt')) {
        showLoading('Carregando v√≠deo...'); // Mostra o loading
        if (videoPlayer.readyState >= 2) { // HAVE_CURRENT_DATA ou melhor
            moveVideoToSection();
        } else {
            // Aguarda os metadados carregarem
            videoPlayer.addEventListener('loadedmetadata', function onLoaded() {
                moveVideoToSection();
                videoPlayer.removeEventListener('loadedmetadata', onLoaded);
            });
        }
    } else {
        moveVideoToSection();
    }
    
    const current = sectionHistory[sectionHistory.length - 1];
    if (targetId !== current) {
        sectionHistory.push(targetId);
    }
    
    // Ativa/desativa se√ß√µes
    sections.forEach(id => {
        const el = document.getElementById(id);
        if (!el) return;
        el.classList.toggle('active', id === targetId);
    });
    
    if (targetId !== 'postLesson' && targetId !== 'editSrt') {
        videoPlayer.pause();
    }
    
    // Lista de se√ß√µes onde o bot√£o "Voltar" deve ser ocultado
    const sectionsToHideBackBtn = ['home', 'search', 'notifications', 'you', 'subscriptions', 'create', 'myPosts', 'profile', 'challenge'];
    
    // Atualiza bot√£o "Voltar"
    const goBackBtn = document.getElementById('btn-goBack');
    if (goBackBtn) {
        goBackBtn.classList.toggle('hidden', sectionsToHideBackBtn.includes(targetId));
    }
    
    // Atualiza footer
    const footerLinks = document.querySelectorAll('footer a');
    footerLinks.forEach(link => link.classList.remove('active'));
    const targetLink = Array.from(footerLinks).find(a => a.getAttribute('onclick')?.includes(targetId));
    if (targetLink) targetLink.classList.add('active');

	 // ‚úÖ MOVIDO PARA C√Å: Chama showFooter() DEPOIS de ativar as se√ß√µes
    // Usa setTimeout para garantir que o DOM foi atualizado
    setTimeout(() => {
        showFooter();
    }, 0);
    
    // Carrega os posts quando mostrar as se√ß√µes
    if (targetId === 'home') {
        loadHomePosts();
    } else if (targetId === 'myPosts') {
        loadUserPosts();
    }
    
    // ‚úÖ ADICIONADO: Ao ENTRAR no editSrt em modo preview, atualiza a UI
    if (targetId === 'editSrt' && window.isPreviewMode) {
        setTimeout(() => {
            updateEditorUI();
            console.log('[showSection] Entrando em editSrt - modo preview ativo');
        }, 100);
    }
    
    // Se est√° entrando no editSrt em modo edi√ß√£o, atualiza a UI
    if (targetId === 'editSrt' && !window.isPreviewMode) {
        setTimeout(() => {
            updateEditorUI();
        }, 100);
    }
}

function goBack() {
  if (sectionHistory.length > 1) {
    sectionHistory.pop(); // Remove a atual
    const previous = sectionHistory[sectionHistory.length - 1];
    
    // ‚úÖ Se voltando para editSrt E estava em preview, mant√©m
    if (previous === 'editSrt' && window.isPreviewMode) {
      console.log("[goBack] Voltando para editSrt em modo preview");
    }
    
    showSection(previous);
  }
}

// ‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò
// ----- Bloco Fx | Loading ----- 
// ‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò

/**
 * Mostra o overlay de loading
 * @param {string} message - Mensagem a ser exibida (opcional)
 */
function showLoading(message = 'Carregando...') {
    const overlay = document.getElementById('loadingOverlay');
    const text = document.getElementById('loadingText');
    if (text) text.textContent = message;
    if (overlay) overlay.classList.add('active');
}

/**
 * Esconde o overlay de loading
 */
function hideLoading() {
    const overlay = document.getElementById('loadingOverlay');
    if (overlay) overlay.classList.remove('active');
}

// ‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò
// ----- Bloco Fx | Login ----- 
// ‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò

// Configura√ß√£o do Appwrite
const client = new Appwrite.Client()
        .setEndpoint('https://nyc.cloud.appwrite.io/v1')
        .setProject('68ebe8640000ca7c860b');

const account = new Appwrite.Account(client);

// Seletores de elementos HTML (TODOS JUNTOS AQUI)

const btnLoginHeader = document.getElementById('btnLogin');

const loginForm = document.getElementById('login-form');
const logoutButton = document.getElementById('logout-button');
const userEmailDisplay = document.getElementById('user-email-display');
const iconCreate = document.getElementById('icon-create');
const btnMyPosts = document.getElementById('btn-myPosts');

const loginMessage = document.getElementById('login-message');

// Fun√ß√£o para verificar o status de login
async function checkAuthStatus() {
    try {
        const user = await account.get();
        renderUIForAuthState(true, user.email);
        showSection('myPosts');
    } catch (error) {
        renderUIForAuthState(false);
        showSection('home');
    }
}
    
// Evento de submiss√£o do formul√°rio de login
loginForm.addEventListener('submit', async (e) => {
    e.preventDefault();
    const email = document.getElementById('email-login').value;
    const password = document.getElementById('password-login').value;
    loginMessage.textContent = '';
    try {
        await account.createEmailPasswordSession(email, password);
        // Atualiza a interface
        const user = await account.get();
        renderUIForAuthState(true, user.email);
        showSection('myPosts');
    } catch (error) {
        loginMessage.textContent = 'Erro no login: ' + error.message;
    }
});

// Fun√ß√£o de logout
function handleLogout() {
    account.deleteSession('current')
        .then(() => {
            renderUIForAuthState(false);
            showSection('home');
        })
        .catch((error) => {
            console.error('Erro ao fazer logout:', error);
        });
}
    
/* Fun√ß√£o para renderizar a interface de
    ** acordo com o estado de autentica√ß√£o */
function renderUIForAuthState(isLoggedIn, userEmail = '') {
    // Esconde tudo primeiro
    iconCreate.style.display = 'none';
    btnMyPosts.style.display = 'none';
    btnLoginHeader.style.display = 'none';
    logoutButton.style.display = 'none';
    userEmailDisplay.style.display = 'none';

    if (isLoggedIn) {
        // Mostra email e bot√£o sair
        userEmailDisplay.textContent = userEmail;
        userEmailDisplay.style.display = 'block';
        logoutButton.style.display = 'block';
    	iconCreate.style.display = 'block';
	    btnMyPosts.style.display = 'block';
    } else {
        // Mostra apenas bot√£o entrar
        btnLoginHeader.style.display = 'block';
    }
}

// Fun√ß√£o para mostrar perfil ou tela de login
async function showProfile() {
    try {
        const user = await account.get();
        // Se conseguiu pegar o usu√°rio, est√° logado
        showSection('profile');
    } catch (error) {
        // Se deu erro, n√£o est√° logado
        showSection('login-screen');
    }
}

checkAuthStatus();

// ‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò
// CACHE DE LI√á√ïES - IN√çCIO
// ‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò

// O 'guarda-roupa' local para as li√ß√µes j√° carregadas.
const lessonCache = new Map();

/**
 * Tenta buscar uma li√ß√£o do cache. Valida se a vers√£o em cache √© a mais recente.
 * @param {string} postId - O ID do post a ser buscado.
 * @returns {Promise<Object|null>} Retorna o objeto com { videoBlob, srtText } se o cache for v√°lido, sen√£o retorna null.
 */
async function getFromCache(postId) {
    if (!lessonCache.has(postId)) {
        console.log('[Cache] Cache miss para a li√ß√£o ' + postId + '.');
        return null; // N√£o est√° no cache.
    }

    const cachedLesson = lessonCache.get(postId);
    
    try {
        // Valida√ß√£o r√°pida: busca apenas o documento para comparar o timestamp
        const postFromServer = await databases.getDocument('68ed87df000874c3e85a', '68ed87f400375b28a7e7', postId);

        if (cachedLesson.timestamp === postFromServer.$updatedAt) {
            console.log("%c[Cache] V√ÅLIDO! Retornando li√ß√£o " + postId + " do cache.", "color: #00ff00; font-weight: bold;");
            return { videoBlob: cachedLesson.videoBlob, srtText: cachedLesson.srtText };
        } else {
            console.warn("[Cache] INV√ÅLIDO! O post " + postId + " foi atualizado. Removendo do cache.");
            lessonCache.delete(postId); // Remove a vers√£o antiga
            return null;
        }
    } catch (error) {
        console.error('[Cache] Erro ao validar o cache. Retornando null.', error);
        return null;
    }
}

/**
 * Salva os dados de uma li√ß√£o (v√≠deo e SRT) no cache local.
 * @param {string} postId - O ID do post.
 * @param {Object} data - Objeto contendo { videoBlob, srtText, timestamp }.
 */
function saveToCache(postId, data) {
    const cacheEntry = {
        videoBlob: data.videoBlob,
        srtText: data.srtText,
        timestamp: data.timestamp
    };
    lessonCache.set(postId, cacheEntry);
    console.log(`%c[Cache] Li√ß√£o ${postId} salva no cache com sucesso!`, 'color: #71e8ff;');
}

// ‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò
// ----- Bloco Fx | Upload ---- 
// ‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò

// Inicializar a inst√¢ncia de Storage com o client
const storage = new Appwrite.Storage(client);

// Fun√ß√£o para fazer upload de um arquivo e retornar o ID
async function uploadFile(file, fileName) {
    try {
        const response = await storage.createFile(
            '68ed7f190017280cf294', // bucketId
            Appwrite.ID.unique(),    // fileId √∫nico
            new File([file], fileName, { type: file.type })
        );
        console.log('Upload bem-sucedido:', response);
        return response.$id; // Retorna o ID do arquivo
    } catch (error) {
        console.error('Erro no upload:', error);
        throw error;
    }
}

// ‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò
// ----- Bloco Fx | Post/Update Lesson ---- 
// ‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò

/**
 * Fun√ß√£o principal para postar ou atualizar uma li√ß√£o
 */
async function postLesson() {
    // Verifica se est√° em modo de edi√ß√£o
    if (window.currentEditingPostId) {
        console.log('[postLesson] Modo edi√ß√£o detectado. Chamando updateLesson()...');
        await updateLesson();
    } else {
        console.log('[postLesson] Modo cria√ß√£o. Criando nova li√ß√£o...');
        await createNewLesson();
    }
}

/**
 * Cria uma nova li√ß√£o (upload inicial)
 */
async function createNewLesson() {
    showLoading('Postando li√ß√£o...'); // Mostra loading
    
    try {
        // Valida se h√° conte√∫do carregado
        if (!subtitleName || srtData.length === 0) {
            alert('Carregue uma legenda SRT primeiro!');
            return;
        }

        const videoElement = document.getElementById('mainVideoPlayer');
        if (!videoElement.src || videoElement.src.startsWith('blob:') === false) {
            alert('Carregue um v√≠deo primeiro!');
            return;
        }

        const thumbnailFile = getCapturedThumbnailFile();
        if (!thumbnailFile) {
            alert('Capture uma thumbnail primeiro!');
            return;
        }

        // Obter o nome base (sem extens√£o) do arquivo SRT
        const baseName = subtitleName.replace(/\.[^/.]+$/, "");

        // Converter SRT em arquivo Blob
        const srtContent = generateSRT();
        const srtBlob = new Blob([srtContent], { type: 'text/plain' });
        const srtFile = new File([srtBlob], `${baseName}.srt`, { type: 'text/plain' });

        // Obter o arquivo de v√≠deo original
        const videoUpload = document.getElementById('videoUpload').files[0];
        if (!videoUpload) {
            alert('Arquivo de v√≠deo n√£o encontrado!');
            return;
        }

        // Renomear o v√≠deo para usar o mesmo nome base
        const videoExtension = videoUpload.name.split('.').pop();
        const videoFile = new File([videoUpload], `${baseName}.${videoExtension}`, { type: videoUpload.type });

        // Renomear a thumbnail
        const thumbFile = new File([thumbnailFile], `${baseName}.jpg`, { type: 'image/jpeg' });

        console.log('[createNewLesson] Iniciando uploads...');
        console.log('- SRT:', srtFile.name);
        console.log('- V√≠deo:', videoFile.name);
        console.log('- Thumbnail:', thumbFile.name);

        // Upload dos 3 arquivos
        showLoading('Enviando legenda...');
        const srtId = await uploadFile(srtFile, srtFile.name);
        console.log('‚úÖ SRT enviado:', srtId);

        showLoading('Enviando v√≠deo...');
        const videoId = await uploadFile(videoFile, videoFile.name);
        console.log('‚úÖ V√≠deo enviado:', videoId);

        showLoading('Enviando thumbnail...');
        const thumbId = await uploadFile(thumbFile, thumbFile.name);
        console.log('‚úÖ Thumbnail enviada:', thumbId);
        
        // Salvar informa√ß√µes no banco de dados
        showLoading('Salvando informa√ß√µes...');
        const DATABASE_ID = '68ed87df000874c3e85a';
        const COLLECTION_ID = '68ed87f400375b28a7e7';

        const postData = {
            videoName: baseName,
            videoId: videoId,
            srtId: srtId,
            thumbId: thumbId,
            description: document.querySelector('input[name="description"]').value,
            channelName: userEmailDisplay.textContent,
            performance: '0%',
            duration: '00:00',
            createdAt: new Date().toISOString()
        };

        await databases.createDocument(
            DATABASE_ID,
            COLLECTION_ID,
            Appwrite.ID.unique(),
            postData
        );

        console.log('‚úÖ Dados salvos no banco de dados');
        hideLoading();
        alert('Li√ß√£o postada com sucesso!');
        showSection('myPosts');
        
    } catch (error) {
        console.error('[createNewLesson] Erro ao postar li√ß√£o:', error);
        hideLoading();
        alert('Erro ao postar li√ß√£o: ' + error.message);
    }
}

/**
 * Atualiza uma li√ß√£o existente
 */
async function updateLesson() {
    showLoading('Atualizando li√ß√£o...'); // Mostra loading
    
    try {
        if (!window.currentEditingPostId) {
            hideLoading();
            alert('Erro: ID do post n√£o encontrado!');
            return;
        }
        
        const DATABASE_ID = '68ed87df000874c3e85a';
        const COLLECTION_ID = '68ed87f400375b28a7e7';
        const BUCKET_ID = '68ed7f190017280cf294';
        
        const postId = window.currentEditingPostId;
        
        console.log('[updateLesson] Iniciando atualiza√ß√£o do post ID:', postId);
        
        // Busca os dados antigos do post
        const oldPost = await databases.getDocument(DATABASE_ID, COLLECTION_ID, postId);
        console.log('[updateLesson] Dados antigos do post:', oldPost);
        
        // üìù 1. Captura os novos dados
        const newVideoName = document.querySelector('input[name="nome"]').value || oldPost.videoName;
        const newDescription = document.querySelector('input[name="description"]').value || oldPost.description;
        const newSrtContent = generateSRT();
        
        console.log('[updateLesson] Novos dados capturados:');
        console.log('- Nome:', newVideoName);
        console.log('- Descri√ß√£o:', newDescription);
        console.log('- SRT (tamanho):', newSrtContent.length, 'caracteres');
        
        // Armazena os IDs antigos para deletar depois
        const oldSrtId = oldPost.srtId;
        const oldThumbId = oldPost.thumbId;
        
        // üì§ 2. Upload do novo SRT
        showLoading('Enviando nova legenda...');
        console.log('[updateLesson] Fazendo upload do novo SRT...');
        const srtBlob = new Blob([newSrtContent], { type: 'text/plain' });
        const srtFile = new File([srtBlob], `${newVideoName}.srt`, { type: 'text/plain' });
        const newSrtId = await uploadFile(srtFile, srtFile.name);
        console.log('‚úÖ Novo SRT enviado:', newSrtId);
        
        // üì§ 3. Upload da nova thumbnail (se foi capturada)
        let newThumbId = oldPost.thumbId;
        if (capturedThumbnailBlob) {
            showLoading('Enviando nova thumbnail...');
            console.log('[updateLesson] Fazendo upload da nova thumbnail...');
            const thumbFile = new File([capturedThumbnailBlob], `${newVideoName}.jpg`, { type: 'image/jpeg' });
            newThumbId = await uploadFile(thumbFile, thumbFile.name);
            console.log('‚úÖ Nova thumbnail enviada:', newThumbId);
        } else {
            console.log('[updateLesson] Mantendo thumbnail antiga:', oldThumbId);
        }
        
        // üíæ 4. Atualiza o registro no banco de dados
        showLoading('Salvando altera√ß√µes...');
        console.log('[updateLesson] Atualizando registro no banco...');
        await databases.updateDocument(
            DATABASE_ID,
            COLLECTION_ID,
            postId,
            {
                videoName: newVideoName,
                srtId: newSrtId,
                thumbId: newThumbId,
                description: newDescription
            }
        );
        console.log('‚úÖ Registro atualizado no banco de dados');
        
        // üóëÔ∏è 5. Deleta os arquivos antigos do Storage
        showLoading('Limpando arquivos antigos...');
        console.log('[updateLesson] Deletando arquivos antigos do Storage...');
        
        try {
            await storage.deleteFile(BUCKET_ID, oldSrtId);
            console.log('‚úÖ SRT antigo deletado:', oldSrtId);
        } catch (error) {
            console.warn('‚ö†Ô∏è N√£o foi poss√≠vel deletar o SRT antigo:', error.message);
        }
        
        // S√≥ deleta a thumbnail antiga se uma nova foi enviada
        if (capturedThumbnailBlob && oldThumbId !== newThumbId) {
            try {
                await storage.deleteFile(BUCKET_ID, oldThumbId);
                console.log('‚úÖ Thumbnail antiga deletada:', oldThumbId);
            } catch (error) {
                console.warn('‚ö†Ô∏è N√£o foi poss√≠vel deletar a thumbnail antiga:', error.message);
            }
        }
        
        console.log('[updateLesson] ‚úÖ Atualiza√ß√£o conclu√≠da com sucesso!');
        hideLoading();
        alert('Li√ß√£o atualizada com sucesso!');
        
        // Limpa o estado de edi√ß√£o
        delete window.currentEditingPostId;
        capturedThumbnailBlob = null;
        
        // Volta para a lista de posts
        showSection('myPosts');
        
    } catch (error) {
        console.error('[updateLesson] ‚ùå Erro ao atualizar li√ß√£o:', error);
        hideLoading();
        alert('Erro ao atualizar li√ß√£o: ' + error.message);
    }
}

// ‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò
// ----- Bloco Fx | Recuperar e Exibir Posts ---- 
// ‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò

const databases = new Appwrite.Databases(client);

/**
 * Busca os posts (li√ß√µes) do banco de dados
 * @returns {Array} Lista de posts
 */
async function fetchPosts() {
    try {
        const DATABASE_ID = '68ed87df000874c3e85a';
        const COLLECTION_ID = '68ed87f400375b28a7e7';
        
        const response = await databases.listDocuments(
            DATABASE_ID,
            COLLECTION_ID
        );
        
        console.log(response.documents);  // Inspecionar os dados dos posts
        return response.documents;
    } catch (error) {
        console.error('Erro ao buscar posts:', error);
        return [];
    }
}

/**
 * Gera a URL da thumbnail a partir do Storage
 * @param {string} thumbId - ID da thumbnail no Storage
 * @returns {string} URL da imagem
 */
async function getThumbnailUrl(thumbId) {
    console.log('thumbId:', thumbId); // Verifique o valor de thumbId aqui
    const BUCKET_ID = '68ed7f190017280cf294'; // O ID do bucket

    try {
        const filePreview = await storage.getFileView(
            BUCKET_ID,      // bucketId
            thumbId,        // fileId
            600,            // width (opcional)
            340,            // height (opcional)
            'center',       // gravity (opcional)
            100             // quality (opcional)
        );

        // Log o retorno da fun√ß√£o para ver o que est√° sendo retornado
        console.log('filePreview:', filePreview);  

        if (filePreview) {
            return filePreview;  // Certifique-se de que o href √© retornado
        } else {
            console.error('N√£o foi poss√≠vel obter a URL da thumbnail.');
            return '';  // Retorna uma string vazia caso o href n√£o esteja presente
        }
    } catch (error) {
        console.error('Erro ao obter thumbnail:', error);
        return '';  // Retorna uma string vazia caso ocorra erro
    }
}

/**
 * Cria o HTML de um card de v√≠deo
 * @param {Object} post - Dados do post (videoName, thumbId, channelName, performance, videoId, srtId, etc)
 * @param {boolean} showEdit - Se deve mostrar o bot√£o "Editar"
 * @returns {string} HTML do card
 */
async function createVideoCard(post, showEdit = false) {
    const thumbUrl = await getThumbnailUrl(post.thumbId);
    
    console.log('thumbUrl:', thumbUrl);

    return `
        <div class="video-container" data-video-id="${post.$id}">
            <div class="video-thumb" onclick="previewLesson('${post.$id}')">
                <img src="${thumbUrl || 'fallback-image.jpg'}" alt="Video thumbnail" class="video-thumb-img">
                <span class="video-time">${post.duration || '10:35'}</span>
            </div>
            <div class="channel-info">
                <div class="channel-pic">
                    <img src="${post.channelPic || 'canal.jpg'}" alt="Canal" class="channel-pic">
                </div>
                <div class="video-text">
                    <h3 class="video-title" onclick="previewLesson('${post.$id}')" style="cursor: pointer;">${post.videoName}</h3>
                    <div class="video-meta">
                        <span class="channel-name">${''}</span>
                        <span class="performance">${post.performance || '95%'}</span>
                        ${showEdit ? `<span class="video-edit" onclick="event.stopPropagation(); editPost('${post.$id}')" style="cursor: pointer; color: #6d28d9; font-weight: bold;">Editar</span>` : ''}
                    </div>
                </div>
            </div>
        </div>
    `;
}

/**
 * Renderiza os posts em um container espec√≠fico
 * @param {string} containerId - ID do container onde os posts ser√£o exibidos
 * @param {boolean} showEdit - Se deve mostrar o bot√£o "Editar"
 */
async function renderPosts(containerId, showEdit = false) {
    const container = document.getElementById(containerId);
    if (!container) {
        console.error(`Container ${containerId} n√£o encontrado`);
        return;
    }
    
    container.innerHTML = '<p>Carregando...</p>';
    
    const posts = await fetchPosts();
    
    if (posts.length === 0) {
        container.innerHTML = '<p>Nenhum post encontrado.</p>';
        return;
    }
    
    // Espera todos os cards serem criados
    const cardsHTML = await Promise.all(posts.map(post => createVideoCard(post, showEdit)));
    container.innerHTML = cardsHTML.join('');
}

/**
 * Carrega os posts para a se√ß√£o Home
 */
function loadHomePosts() {
    renderPosts('home-post-container', false);
}

/**
 * Carrega os posts do usu√°rio (com op√ß√£o de editar)
 */
function loadUserPosts() {
    // Pega o bot√£o de logout para verificar sua visibilidade.
    const logoutBtn = document.getElementById('logout-button');

    // Determina se o usu√°rio est√° autenticado. 
    // O bot√£o s√≥ fica vis√≠vel ('block') quando o usu√°rio est√° logado.
    const isAuthenticated = logoutBtn && logoutBtn.style.display === 'block';

    // Passa o resultado (true ou false) para a fun√ß√£o renderPosts.
    // O bot√£o "Editar" s√≥ ser√° mostrado se isAuthenticated for true.
    renderPosts('user-post-container', isAuthenticated);
}

/**
 * Fun√ß√£o para editar um post
 * @param {string} postId - ID do post a ser editado
 */
function editPost(postId) {
    // Implementar l√≥gica de edi√ß√£o
    console.log('Editar post:', postId);
    // Voc√™ pode carregar os dados do post e abrir a se√ß√£o de edi√ß√£o
}

// Inicializar quando necess√°rio
// Chame essas fun√ß√µes quando mostrar as se√ß√µes correspondentes

// ‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò
// ----- Bloco Fx | Preview Mode ---- 
// ‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò

/**
 * Ajusta a interface do editor SRT de acordo com o modo (preview ou edi√ß√£o)
 */
function updateEditorUI() {
    const isPreview = window.isPreviewMode === true;
    
    console.log('[updateEditorUI] Modo preview:', isPreview);
    
    // Elementos que devem ser ocultados no modo preview
    const elementsToHide = [
        document.getElementById('btn-config'),           // ‚öô Editar em Lote
        document.querySelectorAll('#editor label')[0],   // Label "In√≠cio"
        document.querySelectorAll('.time-controls')[0],  // Controles de tempo In√≠cio
        document.querySelectorAll('#editor label')[1],   // Label "Fim"
        document.querySelectorAll('.time-controls')[1],  // Controles de tempo Fim
        document.querySelectorAll('#editor label')[2],   // Label "Texto"
        document.getElementById('editText'),             // Textarea
        document.getElementById('btn-load'),             // üìÇ
        document.getElementById('btn-save')              // üíæ
    ];
    
    // Oculta ou mostra os elementos
    elementsToHide.forEach(element => {
        if (element) {
            element.style.display = isPreview ? 'none' : '';
        }
    });
    
    // Ajusta os bot√µes de navega√ß√£o para ficarem mais vis√≠veis no preview
    const navButtons = [
        document.querySelector('button[onclick="prevLine()"]'),
        document.querySelector('button[onclick="playLine()"]'),
        document.querySelector('button[onclick="nextLine()"]')
    ];
    
    navButtons.forEach(button => {
        if (button && isPreview) {
            button.style.padding = '15px 20px';
            button.style.fontSize = '18px';
            button.style.margin = '10px 5px';
        } else if (button) {
            button.style.padding = '';
            button.style.fontSize = '';
            button.style.margin = '';
        }
    });
    
    console.log('[updateEditorUI] Interface atualizada para modo:', isPreview ? 'PREVIEW' : 'EDI√á√ÉO');
}

/**
 * Abre o modo de preview (apenas visualiza√ß√£o) de uma li√ß√£o, usando o cache quando poss√≠vel.
 */
async function previewLesson(postId) {
    showLoading('Carregando li√ß√£o...');
    console.log(`[previewLesson] Iniciando preview para o post ID: ${postId}`);

    try {
        // <<< IN√çCIO DA L√ìGICA DE CACHE >>>
        const cachedData = await getFromCache(postId);

        if (cachedData) {
            // Se encontrou no cache, usa os dados de l√°
            const videoUrl = URL.createObjectURL(cachedData.videoBlob);
            document.getElementById('mainVideoPlayer').src = videoUrl;
            parseSRT(cachedData.srtText);
            // Pega o nome do post do cache (ou faz uma busca r√°pida se precisar)
            const cachedPostInfo = await databases.getDocument('68ed87df000874c3e85a', '68ed87f400375b28a7e7', postId);
            document.getElementById('subtitleName').textContent = cachedPostInfo.videoName + '.srt';

        } else {
            // Se n√£o encontrou no cache, busca no servidor (l√≥gica original)
            const DATABASE_ID = '68ed87df000874c3e85a';
            const COLLECTION_ID = '68ed87f400375b28a7e7';
            const BUCKET_ID = '68ed7f190017280cf294';
            
            const post = await databases.getDocument(DATABASE_ID, COLLECTION_ID, postId);

            const videoDownloadUrl = storage.getFileDownload(BUCKET_ID, post.videoId);
            const srtDownloadUrl = storage.getFileDownload(BUCKET_ID, post.srtId);

            const [videoResponse, srtResponse] = await Promise.all([
                fetch(videoDownloadUrl),
                fetch(srtDownloadUrl)
            ]);

            const videoBlob = await videoResponse.blob();
            const srtText = await srtResponse.text();

            // <<< SALVA NO CACHE ANTES DE EXIBIR >>>
            saveToCache(postId, { videoBlob, srtText, timestamp: post.$updatedAt });

            // Usa os dados rec√©m-buscados
            const videoUrl = URL.createObjectURL(videoBlob);
            document.getElementById('mainVideoPlayer').src = videoUrl;
            parseSRT(srtText);
            document.getElementById('subtitleName').textContent = post.videoName + '.srt';
        }
        // <<< FIM DA L√ìGICA DE CACHE >>>

        // L√≥gica de exibi√ß√£o (comum para ambos os casos)
        window.isPreviewMode = true;
        delete window.currentEditingPostId;
        showSection('editSrt');
        
    } catch (error) {
        console.error('[previewLesson] Erro ao carregar preview:', error);
        alert('Erro ao carregar visualiza√ß√£o: ' + error.message);
    } finally {
        hideLoading();
    }
}

/**
 * Toggles the visibility of the main and preview footers
 * based on the global isPreviewMode variable.
 */
function showFooter() {
    const mainFooter = document.getElementById('main-footer');
    const previewFooter = document.getElementById('preview-footer');

    // Safety check to ensure the elements exist
    if (!mainFooter || !previewFooter) {
        console.error('Um ou ambos os footers (main-footer, preview-footer) n√£o foram encontrados.');
        return;
    }

    // ‚úÖ CORRIGIDO: Verifica tamb√©m se est√° na se√ß√£o editSrt ou solo
    const isInEditSrt = document.getElementById('editSrt')?.classList.contains('active');
    const isInSolo = document.getElementById('solo')?.classList.contains('active');
    const shouldShowPreviewFooter = window.isPreviewMode && (isInEditSrt || isInSolo);

    console.log('[showFooter] isPreviewMode:', window.isPreviewMode, '| isInEditSrt:', isInEditSrt, '| isInSolo:', isInSolo);

    if (shouldShowPreviewFooter) {
        // We are in preview mode: show the preview footer
        mainFooter.style.display = 'none';
        previewFooter.style.display = 'flex';
        console.log('[showFooter] Exibindo preview footer');
    } else {
        // We are NOT in preview mode: show the main footer
        mainFooter.style.display = 'flex';
        previewFooter.style.display = 'none';
        console.log('[showFooter] Exibindo main footer');
    }
}

// ‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò
// ----- Bloco Fx | Edit Post ----
// ‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò
/**
 * Fun√ß√£o para carregar um post para edi√ß√£o, usando o cache quando poss√≠vel
 * @param {string} postId - ID do post a ser editado
 */
async function editPost(postId) {
    showLoading('Carregando editor...');
    console.log(`[editPost] Iniciando edi√ß√£o para o post ID: ${postId}`);

    try {
        let postData; // Para guardar os detalhes do post
        
        // <<< IN√çCIO DA L√ìGICA DE CACHE >>>
        const cachedData = await getFromCache(postId);

        if (cachedData) {
            // Se encontrou no cache, usa os dados de l√°
            postData = await databases.getDocument('68ed87df000874c3e85a', '68ed87f400375b28a7e7', postId);
            const videoUrl = URL.createObjectURL(cachedData.videoBlob);
            document.getElementById('mainVideoPlayer').src = videoUrl;
            parseSRT(cachedData.srtText);
        } else {
            // Se n√£o encontrou no cache, busca no servidor
            const DATABASE_ID = '68ed87df000874c3e85a';
            const COLLECTION_ID = '68ed87f400375b28a7e7';
            const BUCKET_ID = '68ed7f190017280cf294';

            postData = await databases.getDocument(DATABASE_ID, COLLECTION_ID, postId);

            const videoDownloadUrl = storage.getFileDownload(BUCKET_ID, postData.videoId);
            const srtDownloadUrl = storage.getFileDownload(BUCKET_ID, postData.srtId);

            const [videoResponse, srtResponse] = await Promise.all([
                fetch(videoDownloadUrl),
                fetch(srtDownloadUrl)
            ]);

            const videoBlob = await videoResponse.blob();
            const srtText = await srtResponse.text();
            
            // <<< SALVA NO CACHE ANTES DE EXIBIR >>>
            saveToCache(postId, { videoBlob, srtText, timestamp: postData.$updatedAt });
            
            // Usa os dados rec√©m-buscados
            const videoUrl = URL.createObjectURL(videoBlob);
            document.getElementById('mainVideoPlayer').src = videoUrl;
            parseSRT(srtText);
        }
        // <<< FIM DA L√ìGICA DE CACHE >>>

        // --- L√≥gica de preenchimento do formul√°rio (comum a ambos os casos) ---
        subtitleName = postData.videoName + '.srt';
        document.getElementById('subtitleName').textContent = subtitleName;

        const thumbUrl = await getThumbnailUrl(postData.thumbId);
        document.getElementById('previewContainer').innerHTML = `<img src="${thumbUrl}" alt="Thumbnail atual">`;
        
        document.querySelector('input[name="nome"]').value = postData.videoName;
        document.querySelector('input[name="description"]').value = postData.description || '';

        window.currentEditingPostId = postId;
        window.isPreviewMode = false; // Garante que n√£o est√° em modo preview
        
        const postButton = document.querySelector('#postLesson button');
        if (postButton) {
            postButton.textContent = 'Atualizar Li√ß√£o';
            postButton.setAttribute('onclick', 'postLesson()');
        }

        // ... (o resto da sua l√≥gica de reativar o bot√£o de captura, etc., se aplicaria aqui)

        showSection('postLesson');

    } catch (error) {
        console.error('[editPost] Erro ao carregar post para edi√ß√£o:', error);
        alert('Erro ao carregar post: ' + error.message);
    } finally {
        hideLoading();
    }
}

// ‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò
// Bloco Edit Srt - Inicio
// ‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò

function closeConfigEdit() {
    document.getElementById('editor').style.display = "block";
    document.getElementById('segments-area').style.display = "block";
    document.getElementById('config-area').style.display = "none";
}

function showConfigEdit() {
    document.getElementById('editor').style.display = "block";
    document.getElementById('segments-area').style.display = "block";
    document.getElementById('config-area').style.display = "block";
}

function renderSegments() {
    // Adicione estes logs
    console.log('--- [renderSegments] Iniciando a renderiza√ß√£o dos segmentos ---');
    console.log(`[renderSegments] Total de segmentos a renderizar: ${srtData.length}`);
    if (srtData.length > 0) {
        console.log('[renderSegments] Amostra do primeiro segmento:', srtData[0]);
    } else {
        console.warn('[renderSegments] AVISO: srtData est√° vazio. Nenhuma legenda para mostrar.');
    }
    // O resto do c√≥digo continua igual
    const container = document.getElementById("segments");
    container.innerHTML = "";

    srtData.forEach(seg => {
        const div = document.createElement("div");
        div.className = "segment";
        div.setAttribute('data-id', seg.id);

        if (seg.id === currentSegment?.id) {
            div.classList.add("segment-selected");
        }

        div.innerHTML = `<b>${seg.id}</b> [${seg.start} ‚Üí ${seg.end}]<br>${seg.text}`;

        div.onclick = () => openEditor(seg.id);

        container.appendChild(div);
    });
}

function openEditor(id) {
  currentSegment = srtData.find(s => s.id === id);
  if (!currentSegment) return;

  document.getElementById("editor").style.display = "block";
  document.getElementById("editStart").value = currentSegment.start;
  document.getElementById("editEnd").value = currentSegment.end;
  document.getElementById("editText").value = currentSegment.text;

  document.getElementById("editStart").oninput = e => handleChange("start", e.target.value);
  document.getElementById("editEnd").oninput = e => handleChange("end", e.target.value);
  document.getElementById("editText").oninput = e => handleChange("text", e.target.value);
  
  // Remove a classe de todos os segmentos
  document.querySelectorAll('.segment').forEach(item => {
    item.classList.remove('segment-selected');
  });
  
  // Adiciona a classe apenas ao segmento atual
  const itemAtivo = document.querySelector(`[data-id="${id}"]`);
  if (itemAtivo) {
    itemAtivo.classList.add('segment-selected');
  }
  
  scrollToSegment(id);
  
  setTimeout(() => playLine(), 500);
}

function handleChange(field, newValue) {
  if (!currentSegment) return;
  const oldValue = currentSegment[field];
  if (oldValue === newValue) return;

  // Cria uma c√≥pia profunda do segmento ANTES da mudan√ßa
  const oldSegment = { ...currentSegment };
  
  undoStack.push({ 
    type: "edit",
    id: currentSegment.id, 
    field, 
    oldValue, 
    newValue,
    segmentBackup: oldSegment // backup completo do segmento
  });
  redoStack = [];
  currentSegment[field] = newValue;
  renderSegments();
}

function adjustTime(field, deltaSeconds) {
  if (!currentSegment) return;

  const oldValue = currentSegment[field];
  const newValue = shiftTime(oldValue, deltaSeconds);

  const idx = srtData.findIndex(s => s.id === currentSegment.id);
  const prev = srtData[idx - 1];
  const next = srtData[idx + 1];

  const toMs = t => {
    const [h, m, rest] = t.split(":");
    const [s, ms] = rest.split(",");
    return (+h * 3600 + +m * 60 + +s) * 1000 + +ms;
  };

  const newMs = toMs(newValue);
  const startMs = toMs(currentSegment.start);
  const endMs = toMs(currentSegment.end);

  if (field === "start" && prev && newMs <= toMs(prev.end) + 0) return;
  if (field === "end" && next && newMs >= toMs(next.start) - 0) return;
  if (field === "start" && newMs >= endMs - 0) return;
  if (field === "end" && newMs <= startMs + 0) return;
  
  // Cria uma c√≥pia profunda do segmento ANTES da mudan√ßa
  const oldSegment = { ...currentSegment };
  
  if (!isBatchEditing) {
    undoStack.push({ 
      type: "edit",
      id: currentSegment.id, 
      field, 
      oldValue, 
      newValue,
      segmentBackup: oldSegment
    });
    redoStack = [];
  }

  redoStack = [];

  currentSegment[field] = newValue;
  updateEditorFields(currentSegment);
  renderSegments();
}

function shiftTime(timeStr, delta) {
  // "00:00:04,500" ‚Üí soma delta (em segundos)
  const [h, m, rest] = timeStr.split(":");
  const [s, ms] = rest.split(",");
  let totalMs = (+h * 3600 + +m * 60 + +s) * 1000 + +ms + delta * 1000;

  if (totalMs < 0) totalMs = 0;
  const hours = Math.floor(totalMs / 3600000);
  const minutes = Math.floor((totalMs % 3600000) / 60000);
  const seconds = Math.floor((totalMs % 60000) / 1000);
  const millis = Math.floor(totalMs % 1000);
  return `${pad(hours)}:${pad(minutes)}:${pad(seconds)},${pad(millis, 3)}`;
}

function pad(num, size=2) {
  return num.toString().padStart(size, "0");
}

// ======================
// ‚Ü© | ‚Ü™ | ‚ò∞ ‚ûñ | ‚ò∞ ‚ûïÔ∏è
// ======================
function undo() {
  if (!undoStack.length) return;
  const last = undoStack.pop();
  redoStack.push(last);

  if (last.type === "add") {
    // Restaura o array completo de antes da adi√ß√£o
    srtData.length = 0;
    srtData.push(...last.stateBefore.map(s => ({...s})));
    currentSegment = srtData[last.currentIndex] || srtData[last.currentIndex - 1] || null;
  } else if (last.type === "remove") {
    // Restaura o array completo de antes da remo√ß√£o
    srtData.length = 0;
    srtData.push(...last.stateBefore.map(s => ({...s})));
    currentSegment = srtData.find(s => s.id === last.segment.id) || null;
  } else if (last.type === "edit") {
    const seg = srtData.find(s => s.id === last.id);
    if (seg) {
      seg[last.field] = last.oldValue;
      currentSegment = seg;
    }
  } else if (last.type === "edit-multiple") {
    srtData.length = 0;
    srtData.push(...last.stateBefore.map(s => ({ ...s })));
    currentSegment = srtData.find(s => s.id === currentSegment?.id) || srtData[0] || null;
  }


  renderSegments();
  if (currentSegment) updateEditorFields(currentSegment);
}

function redo() {
  if (!redoStack.length) return;
  const last = redoStack.pop();
  undoStack.push(last);

  if (last.type === "add") {
    // Restaura o array completo de depois da adi√ß√£o
    srtData.length = 0;
    srtData.push(...last.stateAfter.map(s => ({...s})));
    currentSegment = srtData.find(s => s.id === last.segment.id) || null;
  } else if (last.type === "remove") {
    // Restaura o array completo de depois da remo√ß√£o
    srtData.length = 0;
    srtData.push(...last.stateAfter.map(s => ({...s})));
    currentSegment = srtData[last.currentIndex] || srtData[last.currentIndex - 1] || null;
  } else if (last.type === "edit") {
    const seg = srtData.find(s => s.id === last.id);
    if (seg) {
      seg[last.field] = last.newValue;
      currentSegment = seg;
    }
  } else if (last.type === "edit-multiple") {
    srtData.length = 0;
    srtData.push(...last.stateAfter.map(s => ({ ...s })));
    currentSegment = srtData.find(s => s.id === currentSegment?.id) || srtData[0] || null;
  }

  renderSegments();
  if (currentSegment) updateEditorFields(currentSegment);
}

function addSegment() {
  // Salva o estado ANTES da modifica√ß√£o
  const stateBefore = srtData.map(s => ({...s}));
  
  let insertIndex = srtData.length;
  if (currentSegment) {
    const idx = srtData.findIndex(s => s.id === currentSegment.id);
    insertIndex = idx + 1;
  }

  const newId = insertIndex + 1;
  const newSegment = {
    id: newId,
    start: "00:00:00,000",
    end: "00:00:00,000",
    text: "Novo trecho"
  };
  
  srtData.splice(insertIndex, 0, newSegment);
  
  // Renumera os IDs a partir do ponto de inser√ß√£o
  for (let i = insertIndex + 1; i < srtData.length; i++) {
    srtData[i].id = i + 1;
  }

  // Salva o estado DEPOIS da modifica√ß√£o
  const stateAfter = srtData.map(s => ({...s}));

  undoStack.push({
    type: "add",
    segment: { ...newSegment },
    stateBefore: stateBefore,
    stateAfter: stateAfter,
    currentIndex: insertIndex
  });
  redoStack = [];

  currentSegment = newSegment;
  renderSegments();
  openEditor(currentSegment.id);
}

function removeSegment() {
  if (!currentSegment) return;
  if (srtData.length === 1) return alert("N√£o √© poss√≠vel remover o √∫nico segmento.");

  // Salva o estado ANTES da modifica√ß√£o
  const stateBefore = srtData.map(s => ({...s}));
  
  const idx = srtData.findIndex(s => s.id === currentSegment.id);
  const removedSegment = { ...srtData[idx] };
  srtData.splice(idx, 1);

  // Renumera os IDs ap√≥s a remo√ß√£o
  for (let i = idx; i < srtData.length; i++) {
    srtData[i].id = i + 1;
  }

  // Salva o estado DEPOIS da modifica√ß√£o
  const stateAfter = srtData.map(s => ({...s}));

  undoStack.push({
    type: "remove",
    segment: removedSegment,
    stateBefore: stateBefore,
    stateAfter: stateAfter,
    currentIndex: idx
  });
  redoStack = [];

  currentSegment = srtData[idx] || srtData[idx - 1] || null;

  renderSegments();
  if (currentSegment) openEditor(currentSegment.id);
  else document.getElementById("editor").style.display = "none";
}

function updateEditorFields(seg) {
  document.getElementById("editStart").value = seg.start;
  document.getElementById("editEnd").value = seg.end;
  document.getElementById("editText").value = seg.text;
}

document.addEventListener("keydown", e => {
  if (e.ctrlKey && e.key === "z") { e.preventDefault(); undo(); }
  if (e.ctrlKey && e.key === "y") { e.preventDefault(); redo(); }
});


// ======================
// ‚óÄ‚óÄ | ‚ñ∂‚ñ∂
// ======================
function prevLine() {
  if (!currentSegment) return;
  
  // Limpa timeout e pausa o v√≠deo ANTES de trocar de linha
  if (stopTimeout) {
    clearTimeout(stopTimeout);
    stopTimeout = null;
  }
  
  const videoElement = document.getElementById("mainVideoPlayer");
  if (videoElement && !videoElement.paused) {
    videoElement.pause();
  }
  
  const idx = srtData.findIndex(s => s.id === currentSegment.id);
  if (idx > 0) {
    openEditor(srtData[idx - 1].id);
    scrollToSegment(srtData[idx - 1].id);
  }
}

function nextLine() {
  if (!currentSegment) return;
  
  // Limpa timeout e pausa o v√≠deo ANTES de trocar de linha
  if (stopTimeout) {
    clearTimeout(stopTimeout);
    stopTimeout = null;
  }
  
  const videoElement = document.getElementById("mainVideoPlayer");
  if (videoElement && !videoElement.paused) {
    videoElement.pause();
  }
  
  const idx = srtData.findIndex(s => s.id === currentSegment.id);
  if (idx < srtData.length - 1) {
    openEditor(srtData[idx + 1].id);
    scrollToSegment(srtData[idx + 1].id);
  }
}

function scrollToSegment(id) {
  const segmentsContainer = document.getElementById("segments-area");
  const segments = document.querySelectorAll(".segment");
  
  // Encontra o elemento do segmento pelo √≠ndice (id - 1)
  const targetSegment = segments[id - 1];
  
  if (targetSegment && segmentsContainer) {
    // Usando scrollIntoView para centralizar o segmento
    targetSegment.scrollIntoView({
      behavior: 'smooth',  // Anima√ß√£o suave
      block: 'center'      // Centraliza verticalmente
    });
  }
}

// ======================
// Etidar e lote
// ======================
function showEarlier() {
  shiftSelectedLines(-getCurrentStep());
}

function showLater() {
  shiftSelectedLines(+getCurrentStep());
}

function getCurrentStep() {
  const input = document.getElementById("editStack").value.trim().replace(",", ".");
  const step = parseFloat(input);
  return isNaN(step) || step <= 0 ? TIME_STEP : step;
}

function shiftSelectedLines(delta) {
  const selected = document.querySelector('input[name="opcao-linha"]:checked');
  const value = selected ? selected.value : "current";

  const stateBefore = srtData.map(s => ({ ...s }));
  const prevSegment = currentSegment;

  if (value === "all") {
    isBatchEditing = true;
    srtData.forEach(seg => {
      currentSegment = seg;
      adjustTime("start", delta);
      adjustTime("end", delta);
    });
    isBatchEditing = false;
  } else if (value === "from-current" && currentSegment) {
    const startIdx = srtData.findIndex(s => s.id === currentSegment.id);
    if (startIdx >= 0) {
      isBatchEditing = true;
      for (let i = startIdx; i < srtData.length; i++) {
        currentSegment = srtData[i];
        adjustTime("start", delta);
        adjustTime("end", delta);
      }
      isBatchEditing = false;
    }
  } else if (value === "current" && currentSegment) {
    adjustTime("start", delta);
    adjustTime("end", delta);
  }

  const stateAfter = srtData.map(s => ({ ...s }));

  undoStack.push({
    type: "edit-multiple",
    delta,
    stateBefore,
    stateAfter
  });
  redoStack = [];

  currentSegment = prevSegment;
  renderSegments();
  if (currentSegment) updateEditorFields(currentSegment);
}

// ==================================
// üìÇ Fun√ß√µes de Carregamento 
// ==================================
// Encontre sua fun√ß√£o openContent e substitua-a por esta:
function openContent() {
    const videoUpload = document.getElementById("videoUpload").files[0];
    const srtUpload = document.getElementById("srtUpload").files[0];

    // 1. Carregar o v√≠deo
    if (videoUpload) {
        const videoURL = URL.createObjectURL(videoUpload);
        
        // ‚≠ê CORRIGIDO: Agora atualizamos apenas o player de v√≠deo √∫nico e principal.
        document.getElementById("mainVideoPlayer").src = videoURL;

    } else {
        alert("Selecione um arquivo de v√≠deo para carregar.");
        return;
    }

    // 2. Carregar a legenda (o resto da fun√ß√£o est√° correto)
    if (srtUpload) {
        const reader = new FileReader();
        reader.onload = function (e) {
            parseSRT(e.target.result);
            subtitleName = srtUpload.name;
            document.getElementById("subtitleName").textContent = subtitleName;
            showSection('postLesson');
        };
        reader.readAsText(srtUpload);
    } else {
        srtData = [{ id: 1, start: "00:00:00,000", end: "00:00:05,000", text: "Digite sua legenda aqui" }];
        renderSegments();
        showSection('postLesson');
    }
}

// Fun√ß√£o para interpretar o conte√∫do .srt para srtData
function parseSRT(content) {
  const lines = content.split(/\r?\n/);
  const segments = [];
  let i = 0;

  while (i < lines.length) {
    const id = parseInt(lines[i++]);
    const time = lines[i++];

    if (!time || !time.includes("-->")) continue;

    const [start, end] = time.split("-->").map(s => s.trim().replace(".", ","));
    let text = "";

    while (i < lines.length && lines[i].trim() !== "") {
      text += lines[i++] + "\n";
    }

    segments.push({
      id,
      start,
      end,
      text: text.trim()
    });

    while (i < lines.length && lines[i].trim() === "") i++;
  }

  srtData.length = 0;
  srtData.push(...segments);
  currentSegment = null;
  undoStack = [];
  redoStack = [];
  renderSegments();
}

// Exibir SRT
function showSRT() {
  const srt = generateSRT();
  const novaAba = window.open("", "_blank");

  if (novaAba) {
    novaAba.document.write(`<pre>${srt.replace(/</g, "&lt;").replace(/>/g, "&gt;")}</pre>`);
    novaAba.document.title = "SRT Gerado";
    novaAba.document.close();
  } else {
    alert("N√£o foi poss√≠vel abrir nova aba. Verifique se o bloqueador de pop-up est√° ativo.");
  }
}


function generateSRT() {
  return srtData.map(seg => {
    return `${seg.id}\n${seg.start} --> ${seg.end}\n${seg.text}`;
  }).join("\n\n");
}

function copyToClipboard() {
  const text = generateSRT();
  navigator.clipboard.writeText(text).then(() => {
    alert("Legendas copiadas para a √°rea de transfer√™ncia.");
  });
}

function downSrt() {
  // Verifique se o nome da legenda est√° configurado corretamente
  if (!subtitleName) {
    alert("Erro: Nome da legenda n√£o encontrado.");
    return;
  }

  const blob = new Blob([generateSRT()], { type: "text/plain;charset=utf-8" });
  const url = URL.createObjectURL(blob);
  const a = document.createElement("a");
  a.href = url;
  a.download = subtitleName;  // Usando o nome da legenda carregada
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
  URL.revokeObjectURL(url);
}

// Fun√ß√£o auxiliar para playLine()
// converter o tempo no formato 
// SRT (hh:mm:ss,SSS) para segundos
function parseTime(timeString) {
  const timeParts = timeString.split(/[:,]/);  // Separar por ":" e ","
  const hours = parseInt(timeParts[0], 10);
  const minutes = parseInt(timeParts[1], 10);
  const seconds = parseInt(timeParts[2], 10);
  const milliseconds = parseInt(timeParts[3], 10);

  // Converter tudo para segundos
  return hours * 3600 + minutes * 60 + seconds + milliseconds / 1000;
}

// Busca os tempos de in√≠cio e fim da legenda atual e 
// usa o v√≠deo (ou √°udio) para tocar o trecho
function playLine() {
  if (!currentSegment) {
    alert("Nenhum trecho selecionado.");
    return;
  }

  const videoElement = document.getElementById("mainVideoPlayer");
  if (!videoElement || !videoElement.src) {
    alert("Carregue um v√≠deo primeiro!");
    return;
  }

  // **CR√çTICO: Limpa qualquer timeout anterior**
  if (stopTimeout) {
    clearTimeout(stopTimeout);
    stopTimeout = null;
  }

  // Pausa o v√≠deo se estiver tocando
  if (!videoElement.paused) {
    videoElement.pause();
  }

  const startTime = parseTime(currentSegment.start);
  const endTime = parseTime(currentSegment.end);

  // Aguarda um frame antes de iniciar (garante que pause foi processado)
  requestAnimationFrame(() => {
    videoElement.currentTime = startTime;
    videoElement.play();

    // Configura novo timeout para pausar no fim
    stopTimeout = setTimeout(() => {
      videoElement.pause();
      stopTimeout = null;
    }, (endTime - startTime) * 1000);
  });
}

// ======================
// Inicializar
// ======================
function initSrtEditor() {
    // Garante que o editor e a lista de segmentos est√£o vis√≠veis 
    // e o modo de configura√ß√£o est√° oculto
    document.getElementById('editor').style.display = "block";
    document.getElementById('segments-area').style.display = "block";
    const configArea = document.getElementById('config-area');
    if (configArea) configArea.style.display = "none";
    
    // Renderiza os segmentos
    renderSegments();
    
    // Tenta abrir o primeiro segmento se houver dados
    if (!currentSegment && srtData.length > 0) {
        openEditor(srtData[0].id);
    }
}

// ‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò
//  - Bloco Fx | Thumbnail -
// ‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò‚´ò
// Guarda a thumbnail capturada para ser usada depois. (Como no padr√£o anterior)
let capturedThumbnailBlob = null;

/**
 * Adiciona a funcionalidade de captura a um bot√£o, usando um player de v√≠deo
 * e um container de preview que j√° existem na p√°gina.
 * @param {string} videoId - O ID do elemento <video> j√° carregado.
 * @param {string} buttonId - O ID do <button> que ir√° acionar a captura.
 * @param {string} previewId - O ID do <div> onde a imagem capturada ser√° exibida.
 */
function enableThumbnailCapture(videoId, buttonId, previewId) {
    _injectCaptureStyles();

    const videoElement = document.getElementById(videoId);
    const captureButton = document.getElementById(buttonId);
    const previewContainer = document.getElementById(previewId);

    if (!videoElement || !captureButton || !previewContainer) {
        console.error("Um ou mais elementos (v√≠deo, bot√£o, preview) n√£o foram encontrados na inicializa√ß√£o.");
        return;
    }

    // <<< Log para confirmar que o listener inicial foi configurado
    console.log('--- [enableThumbnailCapture] Listener de captura inicial configurado com sucesso. ---');
    
    let currentPreviewUrl = null;

    captureButton.addEventListener('click', () => {
        // <<< Log de in√≠cio da captura
        console.log('--- [Capture Thumbnail] Bot√£o clicado! (Listener inicial) ---');
        
        // <<< Log para verificar o estado do v√≠deo no momento do clique
        console.log(`[Capture Thumbnail] Dimens√µes do v√≠deo: ${videoElement.videoWidth} x ${videoElement.videoHeight}`);
        console.log(`[Capture Thumbnail] Tempo atual do v√≠deo: ${videoElement.currentTime}`);

        // <<< Valida√ß√£o cr√≠tica para evitar falhas silenciosas
        if (videoElement.videoWidth === 0 || videoElement.videoHeight === 0) {
            console.error('ERRO CR√çTICO: As dimens√µes do v√≠deo s√£o 0. O v√≠deo pode n√£o ter carregado seus metadados ainda.');
            alert('Erro ao capturar: o v√≠deo ainda n√£o est√° pronto. Tente novamente em um instante.');
            return;
        }

        const canvas = document.createElement('canvas');
        canvas.width = videoElement.videoWidth;
        canvas.height = videoElement.videoHeight;
        console.log(`[Capture Thumbnail] Criando canvas com as dimens√µes ${canvas.width} x ${canvas.height}.`);
        
        const ctx = canvas.getContext('2d');
        ctx.drawImage(videoElement, 0, 0, canvas.width, canvas.height);
        console.log('[Capture Thumbnail] Desenhando a imagem do v√≠deo no canvas...');

        canvas.toBlob((blob) => {
            console.log('[Capture Thumbnail] Blob criado com sucesso:', blob); // <<< Mostra o objeto Blob
            capturedThumbnailBlob = blob;
            console.log('[Capture Thumbnail] Vari√°vel global "capturedThumbnailBlob" foi atualizada.');

            if (currentPreviewUrl) {
                URL.revokeObjectURL(currentPreviewUrl);
            }
            currentPreviewUrl = URL.createObjectURL(blob);
            console.log('[Capture Thumbnail] URL de preview gerada:', currentPreviewUrl);
            
            previewContainer.innerHTML = `<img src="${currentPreviewUrl}" alt="Preview da Thumbnail">`;
            console.log('[Capture Thumbnail] Container de preview atualizado.');
        }, 'image/jpeg', 0.9);
    });
}

/**
 * Pega o arquivo da thumbnail que foi capturada.
 * @returns {File|null}
 */
function getCapturedThumbnailFile() {
    if (!capturedThumbnailBlob) {
        return null;
    }
    return new File([capturedThumbnailBlob], "thumbnail.jpg", { type: "image/jpeg" });
}

/**
 * @private Fun√ß√£o auxiliar para injetar o CSS m√≠nimo.
 */
function _injectCaptureStyles() {
    if (document.getElementById('capture-styles')) return;
    const style = document.createElement('style');
    style.id = 'capture-styles';
    style.innerHTML = `
        .thumb-gen-button { width: 100%; padding: 12px; margin-top: 10px; font-size: 16px; font-weight: bold; color: #fff; background-color: #6d28d9; border: none; border-radius: 6px; cursor: pointer; }
        .thumb-gen-preview { width: 100%; min-height: 150px; background-color: #1a1a1a; border: 2px dashed #444; border-radius: 4px; display: flex; align-items: center; justify-content: center; color: #777; margin-top: 16px; overflow: hidden; }
        .thumb-gen-preview img { width: 100%; height: 100%; object-fit: contain; }
    `;
    document.head.appendChild(style);
}

// Ela vai preparar o bot√£o 'captureBtn' para funcionar quando for clicado.
enableThumbnailCapture('mainVideoPlayer', 'captureBtn', 'previewContainer');
		</script>
	</body>
</html>
